[{"title":"mysql数据库之间同步字段","date":"2017-04-30T08:54:18.000Z","path":"2017/04/30/mysql数据库之间同步字段/","text":"项目末尾因为需求的几次改动dev和beta的数据库中的字段出现了几次不一样的情况,所以要找出不一样的部分并去同步他们的字段。当然这种几个数据库中把几十个表字段比较的苦力活落在我身上。 对于这种情况首先我觉得其他人也遇到过，但是起先不知要用什么关键词去寻找答案，后来找到了SQLyog工具同步的方法 以下操作图就是同步的方法","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"经验","slug":"经验","permalink":"http://caoyongjun.com/tags/经验/"}]},{"title":"生活:不该遇到的浪费注意力事件","date":"2017-04-26T03:25:28.000Z","path":"2017/04/26/life/","text":"生活中的遇到的坑早晨在某平台用半小时发了个帖子,本是想会有人赞同我的观点,可是没想还是有一些喷子,大早晨开始就和喷子们撕逼理论把好心情都给弄坏了。读了这么久的笑来老师的文章,居然还是不小心掉进了吞噬时间和注意力的三大坑里导致的后果是本来能在车上睡回笼觉保存体力的 莫名其妙的凑热闹 火急火燎的随大流 操碎了别人的心肝 1.莫名其妙的凑热闹发完帖子,还时不时去看喷子们的留言,真是凑热闹浪费时间 2.操碎了别人的心肝跟我的利益没有太大关联的别人家的事情,我却急的要死。 幸好元认知能力打断了这一切,告诉我的大脑系统不要踩坑远离那个APP,不要在下班之前再次打开帖子。要把所有的注意力放在成长上!!!","comments":true,"tags":[{"name":"生活","slug":"生活","permalink":"http://caoyongjun.com/tags/生活/"}]},{"title":"砖头人项目:7.消息通知功能实现","date":"2017-04-20T07:27:28.000Z","path":"2017/04/20/brickman-message/","text":"1.产品需求 从需求中提取了以下几点要完成 1.添加订阅动作用户 发布，评论，送花，拍砖 会插入到 订阅表(为了订阅到后期有人评论时收到提醒)2.评论内容动作时用户每次对事件评论后产生信息并插入到消息表(为了订阅者获取某个事件的最后一个消息)3.产生消息提醒每次用户登陆或者其他操作时会触发产生消息队列，每次订阅表中获取订阅的事件最后产生的评论信息，放入消息表里4.更新消息已读每次点击进入详情时更新全部的消息提醒 2.设计实现1.uml功能时序图以下图是产生订阅事件信息及提醒信息时序图 以下图是用户触发从提醒表提取未读消息，放入未读表中，以及更改已读消息状态的时序图 3.数据库设计 主要字段解释 （ 红色部分为以后拓展功能时用到的这次不会用到的字段 ） subscription=订阅表:{content_id:“事件Id”,user_id:”用户id”}notify=消息表:{sender_id:”对事件评论的用户id”,content_id:”事件Id“}user_notify=用户未读消息队列:{content_id:“事件Id”,user_id:”用户id”,read_yn:”读取状态”} 3.重要代码实现部分1.利用aop的after 每次拍砖，献花，评论后执行 后续的订阅，和生成评论消息动作， 此次使用aop 其实就是为了怕用户在做完主要动作后还要等待后续的动作会影响用户体验 1234567891011121314&lt;!-- 通知 --&gt;&lt;bean id =\"xmlHandler\" class=\"com.brickman.aop.XMLAdvice\"/&gt; &lt;!-- aop 配置 消息--&gt;&lt;aop:config&gt; &lt;aop:aspect id=\"aspectService\" ref=\"xmlHandler\"&gt; &lt;!-- aop 监听拍砖，献花，评论后 执行 后续插入订阅表和生成评论--&gt; &lt;aop:pointcut id=\"remindPoint\" expression=\"execution(* com.brickman.bo.*.insertRecord(..)) || execution(* com.brickman.bo.*.addComment(..))\"/&gt; &lt;aop:after method=\"doAfterInsertRemind\" pointcut-ref=\"remindPoint\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 2.每次如果订阅表里已经有了之前事件Id那么就更新订阅表的订阅时间 3.用户在登陆或者其他操作时触发生产未读消息队列 重点是找到notify中生成消息时间大于订阅表中的更新时间，并获取最大的notifyId相关数据 1234567SELECT MAX(b.notify_id) AS notify_id,b.content_id AS content_idFROM brick_subscription a,brick_notify bWHERE a.content_id=b.content_id AND a.user_id = #&#123;userId&#125; AND b.sender_id &lt;![CDATA[&lt;&gt;]]&gt; #&#123;userId&#125; AND a.update_time &lt;![CDATA[&lt;]]&gt; b.created_timeGROUP BY b.content_id 4.插入用户提醒队列表时 主要还要判断是否已经有过该事件如果有就不插入，为了避免两次mysql连接直接一次性写在一个sql中 12345678INSERT INTO brick_user_notify ( user_id, content_id, notify_id ) SELECT #&#123;userId&#125;,#&#123;contentId&#125;,#&#123;notifyId&#125; FROM DUAL WHERE NOT EXISTS ( SELECT 1 FROM brick_user_notify WHERE content_id=#&#123;contentId&#125; AND user_id=#&#123;userId&#125; AND notify_id=#&#123;notifyId&#125; ) 点击进入用户未读消息的事件后，会更新某个事件的所有未读消息为已读 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://caoyongjun.com/tags/项目总结/"}]},{"title":"工作经验:针对大批量不同数据生成相同的sql","date":"2017-04-18T16:04:28.000Z","path":"2017/04/19/work-experience/","text":"2013年刚工作不到一年时遇到了一个需求是对大量的数据(几万条词典数据)生成insert语句后给到DBA手里操作。由于工作经验不足的原因,当时自己想了个蠢办法是用方法一:java编写一个读取文件里的内容for循环读取数据然后生成insert的语句…(现在想想只能是一个打30分的低效办法)。后来又遇到了此种需求,如果还要用方法一的话我得改之前的java程序(因为我的当时能力没有写出公用的东西没能供应大多的表和其他如update,delete语句),后来问了下当年带我的师傅龙哥教我用他的方法二excel的方式大致像下面图 方法二图中红色为我要读取并生成的不同的数据,黑色是我固定的要生成的insert语句,”…”是省略。在excel中把这些语句复制粘贴到文本中由于每个excel格中间会有\\t的就是如下的图,可以在文本中替换一下。(现在想想只能是一个打60分勉强及格因为数据量大时会很卡)。 后来又遇到这种需求,庆幸当时的同事老赵教了我一招正则表达式替换,后来举一反三用到了后续的工作,以下是方法三 1(.+)\\t(.+)\\t(.+)\\t(.+)\\t(.+)\\t(.+) 注:每一个”(.+)”对应$i”i这里是1开始的不是0开始,如果是$0的话就是匹配整个内容”按照\\t去匹配的数据如果看不懂正则语法推荐这个博文入门30分钟正则表达式 (推荐使用EmEditor编辑器几万条数据都不会很卡这个方法我打99分,因为我相信还有其他方法更好地满足需求,这个截图是在线的正则工具http://tool.chinaz.com/regex/)","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"经验","slug":"经验","permalink":"http://caoyongjun.com/tags/经验/"}]},{"title":"Windows:cmd杀某个端口进程","date":"2017-04-18T11:54:28.000Z","path":"2017/04/18/windows-cmd/","text":"开发的时候启动tomcat会报端口占用的情况最快的解决方法是打开cmd然后输入一下命令查找到所占用的端口号 12netstat -aon | findstr 6080#就像linux中的ps -ef|grep 6080精确查找到 最后一条为pid 12taskkill /f /pid 41920#就像linux中的kill -9 41920","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"Windows","slug":"Windows","permalink":"http://caoyongjun.com/tags/Windows/"}]},{"title":"砖头人项目:6.MAVEN&GIT项目发布管理","date":"2017-04-17T06:53:28.000Z","path":"2017/04/17/brickman-maven_git/","text":"1.maven安装 123#wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo#yum -y install apache-maven 2.项目采用的是整体代码下载到服务器然后maven编译成class文件，tomcat加载class文件。由于是app接口，但是里面也包含了许多的长期固定不变的jar和一些静态H5页面js|html|css|jpg等信息，要把常修改的和静态不常更新的东西分离 为了动静分离 build_brickman.sh 内容 123456789101112131415161718192021222324#!/bin/shcur_date=$(date +%Y%m%d%H%M%S)folder_name=\"xxx_\"$cur_dateproject_path=/root/projectGitenv=\"dev\"cd $project_pathgit clone git@git.oschina.net:xxxx/xxxx.git $folder_namecd $folder_namemvn -P $env clean compile war:inplacecd $project_pathrm -rf brickmanln -s $folder_name brickmanln -s /data/img/real/html/brickman.html $folder_name/web/brickman.html ln -s /data/img/real/html/brickmanshare.html $folder_name/web/brickmanshare.html build_static_brickman.sh 内容 1234567891011121314151617#!/bin/shcur_date=$(date +%Y%m%d%H%M%S)folder_name=\"html_\"$cur_datestatic_path=/root/staticFilesGitcd $static_pathgit clone git@git.oschina.net:xxx/xxx.git $folder_namemv $folder_name/web/* $folder_name/rm -rf $folder_name/webrm -rf htmlln -s $static_path/$folder_name $static_path/html 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://caoyongjun.com/tags/项目总结/"}]},{"title":"砖头人项目:5.app中banner图片信息获取显示方法","date":"2017-04-16T09:53:28.000Z","path":"2017/04/16/brickman-appbanner/","text":"tomcat启动时一次性获取所有数据库中banner信息初始化到map中，因为常年不变所以每次前端请求时直接从静态map中直接返回对应的banner信息，当真的有banner信息修改时，通过admin方式调用更新map中的相应banner信息即可。主要还是避免每次都去连接宝贵的数据库资源。 1.application-service.xml 加载到这个文件时会触发init-method=”init“方法 12345&lt;bean id=\"commonDAO\" class=\"com.brickman.dao.impl.CommonDAOImpl\"/&gt;&lt;bean id =\"contextUtil\" class=\"com.brickman.utils.ContextUtil\" init-method=\"init\"&gt; &lt;property name=\"commonDAO\" ref=\"commonDAO\"/&gt; &lt;property name=\"advertisementDAO\" ref=\"advertisementDAO\"/&gt;&lt;/bean&gt; 2.初始化 连接数据库信息并存储到一个map中 1234567891011121314151617181920212223242526272829303132333435363738#所有的banner信息放入这个mapprivate static Map&lt;String, List&lt;BrickAdvertisement&gt;&gt; brickAdvertisementMapList = new HashMap&lt;String, List&lt;BrickAdvertisement&gt;&gt;();...省略#init的方法内容List&lt;BrickAdvertisement&gt; brickAdvertisementList01 = new ArrayList&lt;BrickAdvertisement&gt;();//启动页广告List&lt;BrickAdvertisement&gt; brickAdvertisementList02 = new ArrayList&lt;BrickAdvertisement&gt;();//首页广告List&lt;BrickAdvertisement&gt; brickAdvertisementList03 = new ArrayList&lt;BrickAdvertisement&gt;();//中间相机页广告List&lt;BrickAdvertisement&gt; brickAdvertisementList04 = new ArrayList&lt;BrickAdvertisement&gt;();//中间公益页广告 List&lt;BrickAdvertisement&gt; list = advertisementDAO.listAdvertisementByType(null); if (list != null &amp;&amp; list.size() &gt; 0) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; BrickAdvertisement advertisement = list.get(i); //设置他们对应的为止 switch (advertisement.getAdvertisementType()) &#123; case 1: brickAdvertisementList01.add(advertisement); break; case 2: brickAdvertisementList02.add(advertisement); break; case 3: brickAdvertisementList03.add(advertisement); break; case 4: brickAdvertisementList04.add(advertisement); break; default: break; &#125; &#125;&#125;brickAdvertisementMapList.put(\"1\", brickAdvertisementList01);brickAdvertisementMapList.put(\"2\", brickAdvertisementList02);brickAdvertisementMapList.put(\"3\", brickAdvertisementList03);brickAdvertisementMapList.put(\"4\", brickAdvertisementList04); 3.前端获取某个banner类型图片 1List&lt;BrickAdvertisement&gt; list=ContextUtil.getBrickAdvertisementMapList().get(advertisementType); 4.后台admin修改了banner信息，触发更新信息 1234List&lt;BrickAdvertisement&gt; list = advertisementBO.listAdvertisementByType(paramMap);if(list !=null &amp;&amp; list.size()&gt;0)&#123; ContextUtil.getInstance().getBrickAdvertisementMapList().put(advertisementType, list);//重新设置&#125; 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://caoyongjun.com/tags/项目总结/"}]},{"title":"砖头人项目:4.qq登陆授权","date":"2017-04-14T08:49:28.000Z","path":"2017/04/14/brickman-qq_login/","text":"1.引入第三方提供的jar包pom.xml，systemPath为存放路径 1234567&lt;dependency&gt; &lt;groupId&gt;org.other&lt;/groupId&gt; &lt;artifactId&gt;qq&lt;/artifactId&gt; &lt;version&gt;20160812&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;basedir&#125;/web/WEB-INF/lib/Sdk4J.jar&lt;/systemPath&gt;&lt;/dependency&gt; 2.配置qqconnectconfig.properties，前两个参数是申请授权登陆时qq下发的，scope是我们需要用到的作用域获取用户信息 1234567app_ID = **********app_KEY = **********scope = get_user_infobaseURL = https://graph.qq.com/getUserInfoURL = https://graph.qq.com/user/get_user_infoaccessTokenURL = https://graph.qq.com/oauth2.0/token.....省略 3.后端程序获取前端授权qq后返回的数据 accessToken:“授权返回的令牌”，openId:”qq唯一的id” 1234//利用前端返回的信息获取用户的qq空间信息UserInfo qzoneUserInfo = new UserInfo(accessToken, openId);//获取用户详细信息UserInfoBean userInfoBean = qzoneUserInfo.getUserInfo(); 4.然后使用openId查看用户表有无此人，如果无就新生一条用户记录。 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://caoyongjun.com/tags/项目总结/"}]},{"title":"砖头人项目:3.Tomcat配置篇","date":"2017-04-13T08:54:28.000Z","path":"2017/04/13/brickman-tomcat/","text":"1.解压 1tar -zxvf apache-tomcat-7.0.22.tar.gz 2.在%TOMCAT_HOME/conf 下创建一个专门用于砖头人使用的配置文件server-brickman.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;Server port=\"xxxx\" shutdown=\"SHUTDOWN\"&gt; ....省略 &lt;Service name=\"Catalina\"&gt; &lt;Connector port=\"xxxx\" protocol=\"HTTP/1.1\" URIEncoding=\"UTF-8\" #对所有get方式请求进行统一的重新编码解码 useBodyEncodingForURI=\"true\" #根据响应该请求的页面的request.setCharacterEncoding参数对数据进行的重新编码，不同的页面可以有不同的重新编码的编码 connectionTimeout=\"20000\" #当访客网络连接后，服务器等待第一行Request头出现的时间。单位是毫秒 redirectPort=\"xxxx\" #当用户访问非https的资源而该资源又需要https方式访问时，tomcat会自动重定向到https端口，一般https使用 TCP 443端口 maxHttpHeaderSize=\"8192\" #注设置最大的head大小 /&gt; &lt;Connector port=\"xxxx\" protocol=\"AJP/1.3\" redirectPort=\"xxxx\" URIEncoding=\"UTF-8\" useBodyEncodingForURI=\"true\"/&gt; &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; ....省略 &lt;Host name=\"localhost\" #对应虚拟主机,也可以直接填写服务器的 ip unpackWARs=\"false\" #设置是否自动展开 war 压缩包再运行 Web 应用程序，默认值是 true。 autoDeploy=\"false\" #是否允许自动部署,默认值是 true,即表示 Tomcat 会自动检测 appBase 目录下面的文件变化从而自动应用到正在运行的 Web 应用程序。 &gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"/xxx.../logs\" prefix=\"brickman_access_log.\" suffix=\".txt\" pattern=\"combined\" /&gt; &lt;Context docBase=\"/xxx.../brickman/web\" #指定绝对路径一直到web目录下 path=\"\" reloadable=\"false\" #如果是true那么每当相关文件改变时，Tomcat会停止web app并释放内存 allowLinking=\"true\" #因为官网的页面是另一个由nginx管理的静态页面项目，所以使用了软连接指定 /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 3.配置cronolog来管理tomcat产生的日志切割 123456789101112131415161718191、下载（最新版本） #wget http://cronolog.org/download/cronolog-1.6.2.tar.gz 2、解压缩 #tar zxvf cronolog-1.6.2.tar.gz 3、进入cronolog安装文件所在目录 #cd cronolog-1.6.2 4、运行安装 #./configure #make #make install 5、查看cronolog安装后所在目录（验证安装是否成功） #which cronolog 一般情况下显示为：/usr/local/sbin/cronolog 6、要想分割tomcat的catalina.out，需作如下工作：修改%TOMCAT_HOME%/bin目录下的catalina.sh文件中的org.apache.catalina.startup.Bootstrap “$@” start \\&gt;&gt; “$CATALINA_BASE”/logs/catalina.out 2&gt;&amp;1 &amp;替换为org.apache.catalina.startup.Bootstrap \"$@\" start \\ |/usr/local/sbin/cronolog \"$CATALINA_BASE\"/logs/catalina.%Y-%m-%d.out &gt;&gt; /dev/null 2&gt;&amp;1 &amp; 4.启动操作 1%TOMCAT_HOME%/bin/startup.sh -config %TOMCAT_HOME%/conf/server-brickman.xml 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://caoyongjun.com/tags/项目总结/"}]},{"title":"技术:js正则表达式","date":"2017-04-12T10:32:04.000Z","path":"2017/04/12/js-正则表达式/","text":"123var date=\"2017-04-01\";var reg=/\\-/g; //正则表达式，-为需要被换的内容,g为全局的date.replace(reg,\"\"); 结果输出内容为 “20170401”","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"js","slug":"js","permalink":"http://caoyongjun.com/tags/js/"}]},{"title":"砖头人项目:2.Nginx配置篇","date":"2017-04-12T07:50:28.000Z","path":"2017/04/12/brickman-nginx/","text":"砖头人:nginx主要用于项目中的静态资源访问请求，以及拦截爬虫类的攻击请求. 本来想用apache httpd考虑到nginx比较方便配置，就使用nginx了。 1.nginx.conf 配置程序端 由于前期时间域名一直没有通过审核所以，前期使用的是ip访问，后期有了域名后为了支持旧版本以下配置就可支持ip和域名的访问 这里为了保护服务器省略其他配置 只留需要被展示的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445upstream www.brickman.cn&#123; //代理的域名 server localhost:xx; //转跳指定的tomcat端口项目&#125;server &#123; listen 80; server_name localhost; ... ... location / &#123; proxy_pass http://www.brickman.cn; #反向代理域名 ... ... &#125; include agent_deny.conf;#为了防止像性能测试/shell脚本/爬虫类的访问拦截配置 ... ...&#125;server &#123; listen 80; server_name img.brickman.cn;#使用域名后的访问 location ~* ^.+\\.(jpg|js|html|png|css|apk|ttf|woff|ico)$ &#123;#当访问这些后缀时会访问到特定路径下的静态资源 root xxx;#静态路径 add_header Access-Control-Allow-Origin *;#主要是ttf/woff资源在不同域下会丢失 所以加入这个 access_log on; expires 30d;#缓存到用户的机器中30天 &#125; ... ...&#125;server &#123; listen xxxx;#监听静态端口 server_name 127.0.0.1:xxxx;#之前使用ip的时候的访问 location ~* ^.+\\.(jpg|js|html|png|css|apk|ttf|woff|ico)$ &#123; root /data/img/real; add_header Access-Control-Allow-Origin *; access_log on; expires 30d; &#125;&#125; 2.agent_deny.conf 拦截使用的配置 123456789101112131415161718if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123; return 403; &#125; if ($http_user_agent ~ \"FeedDemon|JikeSpider|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|CoolpadWebkit|Java|Feedly|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|YisouSpider|HttpClient|MJ12bot|heritrix|EasouSpider|LinkpadBot|Ezooms|^$\" ) &#123; return 403; &#125; if ($request_method !~ ^(GET|HEAD|POST)$) &#123; return 403; &#125; if ($http_user_agent ~ \"Mozilla/4.0\\ compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727\") &#123; return 404; &#125; if ( $http_user_agent ~ \"ApacheBench|webBench|Java/|http_load|must-revalidate|wget\" )&#123; return 403;&#125; 主要缓存以下资源 官网=http://www.brickman.cn 关于我们=http://img.brickman.cn/html/brickman.html 反馈我们=http://img.brickman.cn/html/brickmanback.html 用户头像和事件的压缩图和原图 最重要的是 vi /etc/hosts 中添加需要的域名 1127.0.0.1 www.brickman.cn brickman.cn img.brickman.cn 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://caoyongjun.com/tags/项目总结/"}]},{"title":"砖头人项目:1.架构设计实现篇","date":"2017-04-11T10:53:28.000Z","path":"2017/04/11/brickman-architecture/","text":"1.服务器使用的是linuxCentOS7 2.git使用码云来托管代码 3.接口文档编写使用showdoc.cc 4.任务分配使用teambition软件 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://caoyongjun.com/tags/项目总结/"}]},{"title":"软件测试神一样的超级好用的selenium 原创java util","date":"2017-04-10T11:37:47.000Z","path":"2017/04/10/selenium/","text":"以下是自己封装的seleniumJava工具类 可以自行拷贝用到项目中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198import java.awt.AWTException;import java.awt.Robot;import java.awt.event.KeyEvent;import java.io.File;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import org.openqa.selenium.JavascriptExecutor;import org.openqa.selenium.TakesScreenshot;import org.apache.commons.io.FileUtils;import org.openqa.selenium.By;import org.openqa.selenium.OutputType;import org.openqa.selenium.WebDriver;import org.openqa.selenium.WebElement;import org.openqa.selenium.chrome.ChromeDriver;import org.openqa.selenium.firefox.FirefoxDriver;import org.openqa.selenium.htmlunit.HtmlUnitDriver;import org.openqa.selenium.ie.InternetExplorerDriver;import org.openqa.selenium.interactions.Actions;import org.openqa.selenium.support.ui.ExpectedCondition;import org.openqa.selenium.support.ui.WebDriverWait;public class SeleniumUtil &#123; private static WebDriver webDriver; private static WebElement webElement; private static Robot robot; private static By byelement; /*javascript*/ public void Script ( String script , WebElement element ) &#123; JavascriptExecutor js=(JavascriptExecutor)webDriver; if ( element==null ) &#123; js.executeScript(script); &#125; else &#123; js.executeScript(script, element); &#125; &#125; /*javascript 返回数据*/ public String ScriptString ( String script ) &#123; JavascriptExecutor js=(JavascriptExecutor)webDriver; String s=(String) js.executeScript(script); return s; &#125; /** * 初始化 * @param select * 1:Firefox * 2:IE * 3:Chrome * 4:后台执行 * @param browserpath * 选择本地浏览路径 */ public void Init ( int switchbrowser , String browserpath ) &#123; switch ( switchbrowser ) &#123; case 1: System.setProperty ( \"webdriver.firefox.bin\" , browserpath ); webDriver = new FirefoxDriver(); webDriver.manage().window().maximize(); break; case 2: System.setProperty(\"webdriver.ie.driver\", browserpath); webDriver = new InternetExplorerDriver(); webDriver.manage().window().maximize(); break; case 3: System.setProperty(\"webdriver.chrome.driver\", browserpath); webDriver = new ChromeDriver(); webDriver.manage().window().maximize(); break; case 4: webDriver = new HtmlUnitDriver(); break; &#125; &#125; //复制 protected void CopyKeys() &#123; try &#123; robot = new Robot(); robot.keyPress(KeyEvent.VK_CONTROL); robot.keyPress(KeyEvent.VK_C); robot.keyRelease(KeyEvent.VK_CONTROL); robot.keyRelease(KeyEvent.VK_C); &#125; catch (AWTException e) &#123; e.printStackTrace(); &#125; &#125; //粘贴 protected void PasteKeys() &#123; try &#123; robot = new Robot(); robot.keyPress(KeyEvent.VK_CONTROL); robot.keyPress(KeyEvent.VK_V); robot.keyRelease(KeyEvent.VK_CONTROL); robot.keyRelease(KeyEvent.VK_V); &#125; catch (AWTException e) &#123; e.printStackTrace(); &#125; &#125; /** * 拖拽 * @param by 要多拽的元素 * @param target 目的地 */ protected void DragAndDrop ( By by , By target ) &#123; (new Actions(webDriver)).dragAndDrop(webDriver.findElement(by), webDriver.findElement(target)).perform(); &#125; //传入值 protected void SendKeys(By by, String value)&#123; webDriver.findElement(by).sendKeys(value); &#125; /** * 截图 * @param outpath 导出截图后的路径 文件名是以当前时间 */ public void GetScreen ( String outpath ) &#123; File screenShotFile = ((TakesScreenshot)webDriver).getScreenshotAs(OutputType.FILE); try &#123; FileUtils.copyFile(screenShotFile, new File ( outpath + \"/\" + getSysTime() + \".jpg\" ) ); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /**获取元素 * @param by * @param second 查找需要时间 */ public void Wait( final By by , int second ) &#123; WebDriverWait wait = new WebDriverWait(webDriver,second); wait.until(new ExpectedCondition&lt;WebElement&gt;()&#123; public WebElement apply(WebDriver d) &#123; return d.findElement(by); &#125; &#125;); &#125; //打开浏览器 public void Start ( String url ) &#123; webDriver.get( url ); &#125; //结束 public void Stop () &#123; webDriver.quit(); &#125; //获取当前时间 public static String getSysTime()&#123; SimpleDateFormat filename = new SimpleDateFormat(\"yyyyMMdd_HHmmss\"); return filename.format(new Date()); &#125; // 睡眠 public void Sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static WebDriver getWebDriver() &#123; return webDriver; &#125; public static void setWebDriver(WebDriver webDriver) &#123; SeleniumUtil.webDriver = webDriver; &#125; public static WebElement getWebElement() &#123; return webElement; &#125; public static void setWebElement(WebElement webElement) &#123; SeleniumUtil.webElement = webElement; &#125; public static By getByelement() &#123; return byelement; &#125; public static void setByelement(By byelement) &#123; SeleniumUtil.byelement = byelement; &#125;&#125;","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://caoyongjun.com/tags/技术/"},{"name":"java","slug":"java","permalink":"http://caoyongjun.com/tags/java/"}]}]