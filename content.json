[{"title":"1.2.对象存活判定算法和垃圾收集算法","date":"2019-03-22T09:15:00.000Z","path":"2019/03/22/jvm-1.2.对象存活判定算法和垃圾收集算法/","text":"gc脑图 如何确定是垃圾1.引用计数法 缺点:无法解决循环引用的问题 2.可达性分析 原理：选择活动的对象作为GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条。 可作为GC Root的对象 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）引用的对象。 可达性分析缺点：在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。 引用类型是什么 出现的理由: 当内存空间还足够时，能保留在内存之中。 如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。 不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。 类型 垃圾回收 应用场景 强引用 不回收 软引用 内存不足时会回收 通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。 弱引用 每次都会回收 这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。 虚引用 回收时会做些事情 通常用来做所谓的 Post-Mortem 清理机制，也有人利用幻象引用监控对象的创建和销毁。 引用状态流转图 对象何时死亡在可达性分析中不可达的对象，不一定会被回收。真正要回收对象至少经历两次标记过程 如果对象在可达性分析后没有与GC Roots引用链相连接，就被第一次标记并进行一次筛选，筛选条件是否有必要执行finalize()方法。（1）当对象没有覆盖finalize()方法（2）finalize()方法已经被jvm调用过。如果没有必要就直接回收对象。 如果有必要执行finalize()，那么这个对象将会放入到F-Queue的队列中，并由低优先级的Finalizer线程去执行触发。稍后gc将对FQueue中的对象进行第二次标记，如果对象在finalize()中重新与引用链的对象建立关联，就会在第二次标记时它将会获得生存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/***此代码演示了两点：*1.对象可以在被GC时自我拯救。*2.这种自救的机会只有一次, 因为一个对象的finalize()方法最多只会被系统自动调用一次*@author zzm*/public class FinalizeEscapeGC &#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() &#123; System.out.println(\"yes,i am still alive:)\"); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(\"finalize mehtod executed!\"); FinalizeEscapeGC.SAVE_HOOK = this; &#125; public static void main(String[] args) throws Throwable &#123; SAVE_HOOK = new FinalizeEscapeGC(); //这种自调用不算入调用次数 SAVE_HOOK.finalize(); // 对象第一次成功拯救自己 SAVE_HOOK = null; System.gc(); // 因为finalize方法优先级很低, 所以暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println(\"no,i am dead:(\"); &#125; // 下面这段代码与上面的完全相同, 但是这次自救却失败了 SAVE_HOOK = null; System.gc(); // 因为finalize方法优先级很低, 所以暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println(\"no,i am dead:(\"); &#125; &#125;&#125; 老版本jdk如何回收方法区主要回收废弃常量和无用的类。 回收废弃常量假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”abc”的，换句话说，就是没有任何String对象引用常量池中的”abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个”abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 回收无用的类 必须满足3个条件 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 垃圾回收算法1. 标记-清除（mark-sweep） 缺点： 造成内存碎片（由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。） 分配效率低 2. 标记-整理（mark-compact）标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。 3. 复制（copy） 内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题。缺点:堆空间的使用效率极其低下。 分代收集算法 新生代（标记-复制算法）通过-XX:SurvivorRatio调整Eden和Survivor的大小比例 Eden Survivor(2个分别用from和to指代（to一直是空）) Minor GC:当Eden区的空间耗尽时触发来收集新生代的垃圾，存活下来的对象会被送到Survivor区。触发时Eden区和from指向的Survivor区中存活对象会被复制到to指向的Survivor区中，然后交换from和to指针。 何时升级到老年代？ JVM会记录对象在Survivor区一共来回复制几次，如果是15就晋升（-XX:+MaxTenuringThreshold） 如果单个Survivor区已经被占用了50%（-XX:TargetSurvivorRatio），较高复制次数的对象也会晋升 老年代（标记-整理|标记-清除算法） 遇到的问题:有些老年代对象可能引用新生代的对象，那么标记该收集哪些类的时候就要连老年代也要去扫描。 HotSpot算法实现1.枚举根节点 如何实现？使用一组OopMap的数据结构，在类加载完成的时候，就把对象内什么偏移量是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。 为了解决什么？每次检查对象存活时必须确保分析过程中对象引用关系在某个冻结的时间点上（Stop the world），并且要逐个从GC Roots节点中检查里面的引用会消耗很多时间。 2.安全点（Safe point） 为了解决什么？在OopMap的协助下，HotSpot会快速且准确地完成GC Roots枚举，可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。 安全点的选定：程序“是否具有让程序长时间执行的特征”为标准进行选定的方法调用、循环跳转、异常跳转等指令才会产生Safepoint gc发生时让所有执行中的线程到达安全点上后停顿下来 抢先式中断（几乎没有jvm会采用这种方法）在gc发生时，首先把所有线程中断，发现有线程中断的地方不在安全点上，就恢复线程，让它到达安全点。 主动式中断当gc需要中断线程的时候，仅仅简单地设置一个标示，各个线程执行时主动去轮询这个标示，如果发现中断标示为真就自己中断挂起。 3.安全区域（Safe Region） 为了解决什么？安全点机制保证了程序执行时进入gc的安全点，但程序不执行（没有分配CPU时间）典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起。 安全区域是什么？指在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始gc都是安全的 工作原理在线程执行到安全区域中的代码时，首先标识自己已进入了安全区，这段时间里gc发生时，就不去管标识为安全区域状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。 读后感笔记来自周志明的《深入理解Java虚拟机（第2版）》","comments":true,"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.caoyongjun.com/tags/jvm/"},{"name":"回顾","slug":"回顾","permalink":"http://www.caoyongjun.com/tags/回顾/"},{"name":"深入jvm","slug":"深入jvm","permalink":"http://www.caoyongjun.com/tags/深入jvm/"}]},{"title":"Spring:基于RedisCacheManager支持的cache","date":"2019-03-21T07:38:00.000Z","path":"2019/03/21/spring-RedisCache/","text":"spring 定义了 org.springframework.cache.CacheManager和org.springframework.cache.Cache接口用来统一不同的缓存技术。 CacheManager是spring提供的抽象接口 Cache接口包含缓存的各种操作(crud) CacheManager的实现 CacheManager 描述 SimpleCacheManager 使用简单的Collection ConcurrentMapCacheManager 使用简单的ConcurrentMap（sptingboot默认实现） NoOpCacheManager 金测试用途，不会实际存储缓存 EhCacheCacheManager 使用EhCache GuavaCacheManager 使用Google Guava的GuavaCache HazelcastCacheManager 使用Hazelcast JCacheCacheManager 支持JCache（JSR-107）标准的实现作为缓存技术，如Apache Commons JCS RedisCacheManager 使用redis作为缓存技术 利用RedisCacheManager实现Cache项目中使用spring-data-redis-1.8.9.RELEASE.jar版本，不同版本之间会有不同地实现。(此版本支持默认过期时间) 需要注册一下CacheManager的Bean 1234567891011121314151617181920212223@Configuration@EnableCachingpublic class CacheManagerConfig &#123; @Bean public CacheManager cacheManager(RedisTemplate redisTemplate) &#123; //序列化 redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new FastJson2JsonRedisSerializer&lt;Object&gt;(Object.class)); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new FastJson2JsonRedisSerializer&lt;Object&gt;(Object.class)); redisTemplate.setDefaultSerializer(new StringRedisSerializer()); RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate); cacheManager.setDefaultExpiration(5L);//默认过期时间5s Map&lt;String,Long&gt; expires=new HashMap&lt;&gt;(); expires.put(\"cache_zset\", 5*60L);//key=cache_zset 5分钟后过期 cacheManager.setExpires(expires); //给特定key过期时间 return cacheManager; &#125;&#125; 声明式缓存注解 注解 解释 @Cacheable 在方法执行前Spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据;若没有数据，调用方法并将方法返回值放进缓存 @CacheEvict 将一条或多条数据从缓存中删除 @CachePut 无论怎样，都会将方法的返回值放到缓存。 @Caching Cacheable、CachePut、CacheEvict的组合注解 @CacheConfig 配置当前类中使用到的公共参数部分 1. @Cacheable例子123456789@Override@Cacheable(value=\"cache_zset\",key=\"'cache_pre:' + #a + '_' + #b + '_' + #c\")public Map&lt;String, Object&gt; list(int a, String b, Long c) &#123; Map&lt;String, Object&gt; map=new HashMap&lt;&gt;(); map.put(\"a\", a); map.put(\"b\", b); map.put(\"c\", c); return map;&#125; 会在redis中存储两份数据结构 一份是zset 123key=cache_zset~keysvalue=cache_pre:#a_#b_#cscore=0 另一份是string 12key=cache_pre:#a_#b_#cvalue=存储的值 常用几个参数说明 参数 说明 例子 value 存入的缓存的名称 cacheNames 和value相同 key 根据传入的参数生成的对应方法的缓存值 condition 缓存的条件 condition=&quot;#a==1&quot;代表只有传入值a等于1时才缓存数据 unless 不缓存的条件，方法执行后触发 unless=&quot;#result==null&quot;代表返回值空时不缓存数据 2. @CacheEvit例子12345@Override@CacheEvict(value=\"cache_zset\",key=\"'cache_pre:' + #a + '_' + #b + '_' + #c\",condition=\"#a==1\")public void delete(int a, String b, Long c) &#123; System.out.println(\"aaaaaaaaa\");&#125; 常用几个参数说明 参数 说明 例子 value 存入的缓存的名称 cacheNames 和value相同 key 根据传入的参数生成的对应方法的缓存值 condition 缓存的条件 condition=&quot;#a==1&quot;代表只有传入值a等于1时才缓存数据 allEntries 是否删除全部缓存，默认false true时不管condition直接删除@Cacheable的value值 beforeInvocation 是否方法调用之前删除 默认false 建议方法调用后且没有异常退出时删除缓存 3.@CachePut例子和@Cacheable类似，不过@CachePut每次都会执行方法，而@Cacheable先查询缓存如果缓存没值才执行方法 12345678910@Override@CachePut(value=\"cache_zset\",key=\"'cache_pre:' + #a + '_' + #b + '_' + #c\",condition=\"#a==1\",unless=\"#result==null\")public Map&lt;String,Object&gt; update(int a, String b, Long c)&#123; //每次调用都会执行该方法，并且缓存到redis Map&lt;String, Object&gt; map=new HashMap&lt;&gt;(); map.put(\"a\", a); map.put(\"b\", b); map.put(\"c\", c); return map;&#125; 常用几个参数说明 参数 说明 例子 value 存入的缓存的名称 cacheNames 和value相同 key 根据传入的参数生成的对应方法的缓存值 condition 缓存的条件 condition=&quot;#a==1&quot;代表只有传入值a等于1时才缓存数据 unless 不缓存的条件，方法执行后触发 unless=&quot;#result==null&quot;代表返回值空时不缓存数据 4.@Caching例子1234567891011@Override@Caching(cacheable=&#123;@Cacheable(value=\"cache_zset\",key=\"'cache_pre:' + #a + '_' + #b + '_' + #c\",unless=\"#result==null\")&#125;, put=&#123;@CachePut(value=\"cache_zset\",key=\"'cache_pre:' + #a + '_' + #b + '_' + #c\",unless=\"#result==null\")&#125;, evict=&#123;@CacheEvict(value=\"cache_zset\",key=\"'cache_pre:' + #a + '_' + #b + '_' + #c\",condition=\"#a==1\")&#125;)public Map&lt;String, Object&gt; caching(int a, String b, Long c) throws Exception &#123; Map&lt;String, Object&gt; map=new HashMap&lt;&gt;(); map.put(\"a\", a); map.put(\"b\", b); map.put(\"c\", c); return map;&#125; 5.@CacheConfig例子如果在类中定义了@CacheConfig那么此类下的所有value=”xyz”就共用此config的cacheNames1234567891011121314@CacheConfig(cacheNames=\"cache_zset\")public class CacheFacadeImpl implements CacheFacade &#123; @Override @Caching(cacheable=&#123;@Cacheable(key=\"'cache_pre:' + #a + '_' + #b + '_' + #c\",unless=\"#result==null\")&#125;, put=&#123;@CachePut(key=\"'cache_pre:' + #a + '_' + #b + '_' + #c\",unless=\"#result==null\")&#125;, evict=&#123;@CacheEvict(key=\"'cache_pre:' + #a + '_' + #b + '_' + #c\",condition=\"#a==1\")&#125;) public Map&lt;String, Object&gt; caching(int a, String b, Long c) throws Exception &#123; Map&lt;String, Object&gt; map=new HashMap&lt;&gt;(); map.put(\"a\", a); map.put(\"b\", b); map.put(\"c\", c); return map; &#125;&#125; 其他问题key如果不分配时会出现org.springframework.cache.interceptor.SimpleKey cannot be cast to java.lang.String12345678@Cacheablepublic Map&lt;String, Object&gt; list(int a, String b, Long c) &#123; Map&lt;String, Object&gt; map=new HashMap&lt;&gt;(); map.put(\"a\", a); map.put(\"b\", b); map.put(\"c\", c); return map;&#125; 找到Cache配置类继承并重写keyGenerator方法，让它有自动生成key策略12345678910111213141516171819@Configuration@EnableCachingpublic class CacheManagerConfig extends CachingConfigurerSupport &#123; @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator() &#123; public Object generate(Object target, Method method, Object... objects) &#123; StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : objects) &#123; sb.append(obj.toString()); &#125; return sb.toString(); &#125; &#125;; &#125;&#125; 会在redis中存储两份数据结构 一份是zset 123key=cache_zset~keysvalue=com.example.facade.impl.CacheFacadeImpllist#a#b#c //生成key策略导致的score=0 另一份是string 12key=com.example.facade.impl.CacheFacadeImpllist#a#b#cvalue=存储的值","comments":true,"tags":[{"name":"spring","slug":"spring","permalink":"http://www.caoyongjun.com/tags/spring/"},{"name":"redis","slug":"redis","permalink":"http://www.caoyongjun.com/tags/redis/"},{"name":"cache","slug":"cache","permalink":"http://www.caoyongjun.com/tags/cache/"}]},{"title":"1.1.JVM内存区域和内存溢出","date":"2019-03-19T09:43:00.000Z","path":"2019/03/19/jvm-1.1.JVM内存区域和内存溢出/","text":"JVM是运行java代码的假想的计算机，是运行在操作系统之上的，不与硬件直接交互。 包含了以下 字节码指令集 寄存器 栈 垃圾回收 堆 存储方法域 线程私有1.程序计数器 当前线程所执行的字节码的行号指示器。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 程序计数器的作用：由于jvm的多线程是通过线程轮流切换并分配处理器执行时间方式实现，所以一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。 执行什么方法 存放的是什么 Java方法 当前执行的方法时的JVM指令地址 Native方法 （Undefined） 2.虚拟机栈 描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame），随着方法结束而销毁。 何时确定局部变量空间大小？编译期 局部变量空间除了（64位长度的long和double类型占用2个Slot）其余占用1个Slot 栈帧 存放 局部变量表 1）编译期可知的基本数据类型 2）对象引用 3）returnAddress类型（指向了一条字节码指令的地址） 操作栈 - 动态链接 - 方法出口 - 3.本地方法栈 方法 不同 虚拟机栈 为JVM执行Java方法（字节码）服务 本地方法栈 为JVM使用Native方法服务 线程共享4.堆 jvm启动时创建，唯一目的是存放对象实例。 创建的对象和数组都保存在这里，也是垃圾收集器进行垃圾收集的最重要的区域。 由于现在收集器基本都用分代收集算法，所以还分为新生代和老年代。 5.方法区存放 类结构信息 常量 静态变量 方法代码 6.运行时常量池方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 堆中给对象分配内存策略 指针碰撞：假设堆中内存时绝对规整的，左边放着用过的内存，中间放着指针作为分界点的指示器，右边是空闲的内存，每次分配堆存就是把指针向空闲那边挪动一段与对象大小相等的距离。 空闲列表：堆中内存不规整时，jvm必须维护一个列表，记录那些内存时可用的，分配对象时从列表中找到一块足够大的空间划分给对象实例，并更新列表记录。 选择分配方式是由垃圾收集器是否带有压缩整理功能决定 1.对象的内存布局 布局 存储内容 用途 对象头 哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间等 用于存储对象自身的运行时数据 类型指针 jvm通过这个指针来确定这个对象时那个类的实例 实例数据 对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容 对齐填充 非必然存在 仅仅起着占位符的作用 2.对象的访问定位 句柄：实现：堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址优点：reference中存储的是稳定的句柄地址，gc发生时很多对象会被移动，但只会改变句柄中的实例数据指针，不会改变reference本身。 直接指针：（Sun HotSpot使用这方式）实现：reference中存储的直接就是对象地址优点：速度快，节省了一次指针定位的时间开销 内存溢出OutOfMemoryError没有空闲内容，并且垃圾收集器也无法提供更多内存。 内存区域出现OOM的地方（程序计数器不出现OOM） 区域 原因 虚拟机栈 如果扩展时无法申请到足够的内存 本地方法栈 和虚拟机栈一样 堆 可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者出现 JVM 处理引用不及时，导致堆积起来，内存无法释放等。 方法区老版本 因为永久代大小有限，并且JVM对永久代（常量池回收、卸载不再需要的类型）GC不积极，所以不断新添加类型的时候就会出现OOM，类似Intern字符串缓存占用太多空间也会OOM 直接内存 NIO技术直接通过Native函数库分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 虚拟机栈和方法栈还会出现StackOverFlowError：不断递归调用，而且没有退出条件时，就会导致不断压栈。 读后感笔记来自周志明的《深入理解Java虚拟机（第2版）》","comments":true,"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.caoyongjun.com/tags/jvm/"},{"name":"回顾","slug":"回顾","permalink":"http://www.caoyongjun.com/tags/回顾/"},{"name":"深入jvm","slug":"深入jvm","permalink":"http://www.caoyongjun.com/tags/深入jvm/"}]},{"title":"自定义类对象利用TreeSet排序","date":"2019-01-29T08:11:00.000Z","path":"2019/01/29/set-TreeSet自定义类排序/","text":"利用TreeSet类和java.lang.Comparable接口实现给对象集合排序 TreeSet继承关系 TreeSet排序规则 使用二叉树的原理对新add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。 1234567891011121314151617181920212223//实现接口public class Model implements Comparable&lt;Model&gt;&#123; private int age; private String name; public Model(int age,String name)&#123; this.age=age; this.name=name; &#125; //重写方法 @Override public int compareTo(Model o) &#123; if(this.age&gt;o.age)&#123; return 1; &#125;else if(this.age&lt;o.age)&#123; return -1; &#125;else&#123; return 0; &#125; &#125; //省略getter和setter方法...&#125; main方法12345678910111213141516171819public static void main(String[] args) &#123; Set&lt;Model&gt; tree=new TreeSet&lt;&gt;(); Model m1=new Model(1,\"1\"); Model m3=new Model(3,\"3\"); Model m2=new Model(2,\"2\"); Model m5=new Model(5,\"5\"); Model m4=new Model(4,\"4\"); tree.add(m1); tree.add(m3); tree.add(m2); tree.add(m5); tree.add(m4); Iterator&lt;Model&gt; it=tree.iterator(); while(it.hasNext())&#123; System.out.print(it.next().getAge()+\" \"); &#125;&#125; 输出结果为11 2 3 4 5","comments":true,"tags":[{"name":"set","slug":"set","permalink":"http://www.caoyongjun.com/tags/set/"}]},{"title":"手把手搭建项目-SpringCloud-zuul网关配置","date":"2019-01-23T07:15:00.000Z","path":"2019/01/23/springcloud-zuul-网关配置/","text":"启动网关服务12进入D:\\work\\cyj\\application\\script./gateway_start.sh 应用日志在1D:\\work\\cyj\\application\\logs\\gateway.2019-01-10.log 项目配置pom.xml中主要的jar123456789101112131415161718192021222324 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入网关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; application启动类GatewayZuulApplication.java1234567891011121314//开启网关注解@EnableZuulProxy@SpringBootApplicationpublic class GatewayZuulApplication &#123; //配置请求网关前打印请求日志 @Bean public PreRequestLogFilter preRequestLogFilter()&#123; return new PreRequestLogFilter(); &#125; public static void main(String[] args) &#123; SpringApplication.run(GatewayZuulApplication.class, args); &#125;&#125; PreRequestLogFilter.java12345678910111213141516171819202122232425262728public class PreRequestLogFilter extends ZuulFilter &#123; private static final Logger LOGGER=LoggerFactory.getLogger(PreRequestLogFilter.class); @Override public Object run() &#123; RequestContext ctx=RequestContext.getCurrentContext(); HttpServletRequest request=ctx.getRequest(); LOGGER.info(\"send &#123;&#125; request to &#123;&#125;\",request.getMethod(),request.getRequestURL().toString()); return null; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public int filterOrder() &#123; return 1; &#125; @Override public String filterType() &#123; return \"pre\"; &#125;&#125; 配置文件application.properties12345678910spring.profiles.active=localspring.application.name=gatewayserver.port=1080eureka.client.service-url.defaultZone=http://cyj:cyj@localhost:8761/eureka/eureka.instance.prefer-ip-address=truelogging.config=classpath:logback.xml#代理所有微服务api以后的zuul.routes.api.path=/api/** 日志logback.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;include resource=\"org/springframework/boot/logging/logback/default.xml\"/&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"rollingFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;D://work/cyj/application/logs/gateway.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;appender-ref ref=\"rollingFile\" /&gt; &lt;/root&gt; &lt;logger name=\"com.cyj\" level=\"debug\"/&gt; &lt;jmxConfigurator/&gt;&lt;/configuration&gt;","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"搭建项目","slug":"搭建项目","permalink":"http://www.caoyongjun.com/tags/搭建项目/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.caoyongjun.com/tags/SpringCloud/"}]},{"title":"手把手搭建项目-SpringCloud-eureka注册中心配置","date":"2019-01-23T07:12:00.000Z","path":"2019/01/23/springcloud-eureka-注册中心配置/","text":"启动eureka注册中心服务123进入D:\\work\\cyj\\application\\script./eureka_start1.sh./eureka_start2.sh 应用日志在12D:\\work\\cyj\\application\\logs\\eureka1.2019-01-10.logD:\\work\\cyj\\application\\logs\\eureka2.2019-01-10.log 访问注册中心cyj.com:8761 输入用户名和密码 项目配置pom.xml中主要的jar12345678910111213141516171819202122232425 &lt;!--eureka服务jar--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--用于加密注册访问--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; application启动类EurekaServerApplication.java123456789//开启服务注册注解@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 配置文件application-peer1.properties123456789101112131415161718#服务名spring.application.name=discovery-eureka-ha#配置spring.profiles=peer1#该服务端口server.port=8761#关闭注册中心的保护机制，Eureka 会统计15分钟之内心跳失败的比例低于85%将会触发保护机制，不剔除服务提供者，如果关闭服务注册中心将不可用的实例正确剔除 默认falseeureka.server.enable-self-preservation=false#将自己注册到另一个注册中心服务eureka.client.service-url.defaultZone=http://cyj:cyj@localhost:8762/eureka/#不使用主机名来定义注册中心的地址，而使用IP地址的形式，如果设置了eureka.instance.ip-address 属性，则使用该属性配置的IP，否则自动获取除环路IP外的第一个IP地址eureka.instance.prefer-ip-address=true#需用密码来注册security.basic.enabled=truesecurity.user.name=cyjsecurity.user.password=cyj#日志配置logging.config=classpath:logback1.xml 日志logback1.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;include resource=\"org/springframework/boot/logging/logback/default.xml\"/&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"rollingFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;D://work/cyj/application/logs/eureka1.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;appender-ref ref=\"rollingFile\" /&gt; &lt;/root&gt; &lt;logger name=\"com.cyj\" level=\"debug\"/&gt; &lt;jmxConfigurator/&gt;&lt;/configuration&gt;","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"搭建项目","slug":"搭建项目","permalink":"http://www.caoyongjun.com/tags/搭建项目/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.caoyongjun.com/tags/SpringCloud/"}]},{"title":"手把手搭建项目-nginx配置[windows下]","date":"2019-01-23T06:57:00.000Z","path":"2019/01/23/nginx-配置[windows下]/","text":"启动1D:\\work\\cyj\\nginx\\nginx.exe 设置windows下的hosts添加cyj.com域名1127.0.0.1 cyj.com nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; fastcgi_intercept_errors on; #反向代理 这里1080是我们的网关应用的端口号 upstream cyj.com&#123; server localhost:1080; &#125; server &#123; listen 80; server_name cyj.com; charset UFT-8; access_log logs/cyj.access.log; location / &#123; root index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://cyj.com; proxy_connect_timeout 100000; proxy_send_timeout 100000; proxy_read_timeout 100000; proxy_intercept_errors on; if ($request_filename ~* ^.*?/([^/]*?)$) &#123; set $filename $1; &#125; if ($filename ~* ^.*?\\.(eot)|(ttf)|(woff)$)&#123; add_header Access-Control-Allow-Origin *; &#125; &#125; #引入防止脚本类似jmeter的访问和爬虫访问 include agent_deny.conf; &#125;&#125; agent_deny.conf123456789101112131415if ($http_user_agent~ * (Scrapy | Curl | HttpClient)) &#123; return 403;&#125;if ($http_user_agent~\"FeedDemon|JikeSpider|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|CoolpadWebkit|Java|Feedly|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|YisouSpider|HttpClient|MJ12bot|heritrix|EasouSpider|LinkpadBot|Ezooms|^$\") &#123; return 403;&#125;if ($request_method ! ~ ^ (GET | HEAD | POST) $) &#123; return 403;&#125;if ($http_user_agent~\"Mozilla/4.0\\ compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727\") &#123; return 404;&#125;if ($http_user_agent~\"ApacheBench|webBench|Java/|http_load|must-revalidate|wget\") &#123; return 403;&#125;","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"搭建项目","slug":"搭建项目","permalink":"http://www.caoyongjun.com/tags/搭建项目/"},{"name":"nginx","slug":"nginx","permalink":"http://www.caoyongjun.com/tags/nginx/"}]},{"title":"手把手搭建项目-jenkins配置项目[windows下]","date":"2019-01-23T06:44:00.000Z","path":"2019/01/23/jenkins-配置项目[windows下]/","text":"启动项目12cd D:\\work\\cyj\\jenkinsjava -jar jenkins.war --httpPort=8888 配置信息在1C:\\Users\\win10\\.jenkins 系统配置###【系统管理】-&gt;【全局工具配置】配置系统中需要的工具具体位置 ###【系统管理】-&gt;【插件管理】-&gt;【Advanced】配置proxy Update Site路径为1http://updates.jenkins-ci.org/download/plugins/ 项目配置###【首页】-&gt; 【new任务】 配置git信息填写git的路径 点击add添加访问git权限 配置maven 配置shell [注]这里由于是在windows环境所以git shell方式(ps -ef)取不到进程,在这里花了挺长时间找解决方案，最终这里用到了windows的powershell写了个bat批处理结束进程 文件 kill_application.bat 获取要杀的端口号后查找该占用的pid，循环杀123456789101112131415@echo onset input_port=%1%for /f \"tokens=5\" %%i in ('netstat -aon ^| findstr \":%input_port%\"') do ( set n=%%i)echo \"%n%\"if \"%n%\" NEQ \"\" ( if \"%n%\" NEQ \"0\" ( taskkill /f /pid %n% )) 杀完进程后，是把下载好的jar包进行maven打包编译，然后启动项目","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"jenkins","slug":"jenkins","permalink":"http://www.caoyongjun.com/tags/jenkins/"},{"name":"搭建项目","slug":"搭建项目","permalink":"http://www.caoyongjun.com/tags/搭建项目/"},{"name":"bat命令","slug":"bat命令","permalink":"http://www.caoyongjun.com/tags/bat命令/"}]},{"title":"java-数量格式化工具类","date":"2018-12-04T08:30:00.000Z","path":"2018/12/04/java-数量格式化工具类/","text":"项目需求,每逢万和亿单位时要转成以下格式 1234567891011121314151===&gt;110===&gt;101000===&gt;1,00012500===&gt;1.25万10200===&gt;1.02万10000===&gt;1.00万10001200===&gt;1,000.12万1002500===&gt;100.25万1000000===&gt;100.00万10001100===&gt;1,000.11万10001200===&gt;1,000.12万10001000===&gt;1,000.10万10000000===&gt;1,000.00万156000000===&gt;1.56亿 工具类代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class FormatUtils &#123; public static String format(String text) &#123; DecimalFormat df = null; if (text.indexOf(\".\") &gt; 0) &#123; if (text.length() - text.indexOf(\".\") - 1 == 0) &#123; df = new DecimalFormat(\"###,##0.\"); &#125; else if (text.length() - text.indexOf(\".\") - 1 == 1) &#123; df = new DecimalFormat(\"###,##0.0\"); &#125; else &#123; df = new DecimalFormat(\"###,##0.00\"); &#125; &#125; else &#123; df = new DecimalFormat(\"###,##0\"); &#125; double number = 0.0; try &#123; number = Double.parseDouble(text); &#125; catch (Exception e) &#123; number = 0.0; &#125; return df.format(number); &#125; public static String formatNumber(String str) &#123; if(ObjectUtils.isEmpty(str))&#123; return str; &#125; String newStr=\"\"; if(str.length()&lt;=4)&#123; newStr=format(str); &#125;else if(4&lt;str.length() &amp;&amp; str.length()&lt;=8)&#123; String firstStr=str.substring(0, str.length()-4); String lastStr=str.substring(str.length()-4, str.length()-2); newStr=format(firstStr)+\".\"+lastStr+\"万\"; &#125;else&#123; String firstStr=str.substring(0, str.length()-8); String lastStr=str.substring(str.length()-8, str.length()-6); newStr=format(firstStr)+\".\"+lastStr+\"亿\"; &#125; return newStr; &#125; /** * 由于数据库里存储的是分单位，所以金额转换时要除以100得到元单位 * @param origin=分单位（比如1元1毛==&gt;110,55元==&gt;5500） * @return */ public static String formatNumberThousand(long origin) &#123; if(origin==0L)&#123; return \"0\"; &#125; return formatNumber(origin/100L+\"\"); &#125; /* * 订单数 1 10 100单 1,000单 1.25万单 1.02万单 1.20万单 1.00万单 1,000.12万单 销售额 1 10 100 1,000 1.25万 1.02万元 1.20万 1.00万 100.25万 100.00万 1,000.12万 1,000.10 万元 1,000.00 万元 1.56亿 人数 1 10 100人 1,000人 1.25万人 1.02万人 1.20万人 1.00万人 100.25万人 1，000.11万人 1,000.00 万人1.56亿人 产品数量 1 10 100件 1,000件 1.25万件 1.02万件 1.20万件 1.00万件 100.25万件 1，000.11万件 1,000.00 万件 1.56亿件 */ private static List&lt;String&gt; list=Lists.newArrayList(\"1\",\"10\",\"1000\",\"12500\",\"10200\",\"10000\",\"10001200\",\"1002500\",\"1000000\",\"10001100\",\"10001200\",\"10001000\",\"10000000\",\"156000000\"); public static void main(String[] args)&#123; for(String str:list)&#123; if(str.length()&lt;=4)&#123; String newStr=format(str); System.out.println(str+\"===&gt;\"+newStr); &#125;else if(4&lt;str.length() &amp;&amp; str.length()&lt;=8)&#123; String firstStr=str.substring(0, str.length()-4); String lastStr=str.substring(str.length()-4, str.length()-2); String newStr=format(firstStr)+\".\"+lastStr+\"万\"; System.out.println(str+\"===&gt;\"+newStr); &#125;else&#123; String firstStr=str.substring(0, str.length()-8); String lastStr=str.substring(str.length()-8, str.length()-6); String newStr=format(firstStr)+\".\"+lastStr+\"亿\"; System.out.println(str+\"===&gt;\"+newStr); &#125; &#125; &#125;&#125;","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"}]},{"title":"redis持久化","date":"2018-11-01T03:41:18.000Z","path":"2018/11/01/redis-持久化/","text":"1.快照-将内存数据的二进制序列化 写时复制COW(Copy On Write)原理：当需要修改某个元素时，不直接修改，而是先复制一份副本，在副本上进行修改后，把原来的引用指向副本上。 自动触发快照配置 配置 说明 save 900 1 900 秒内如果至少有 1 个 key 的值变化，则保存 save 300 10 300 秒内如果至少有 10 个 key 的值变化，则保存 save 60 10000 60 秒内如果至少有 10000 个 key 的值变化，则保存 save “” 停用快照 手动触发快照命令 命令 说明 缺点 save 阻塞当前redis服务，直到rdb过程完成为止。 对内存比较大的实例会造成长时间阻塞 bgsave (redis机制默认使用该方式)redis在后台异步执行快照，不会阻塞redis，具体操作是通过fork操作子进程负责 - 快照优劣势 优点 缺点 文件紧凑，适合备份和恢复 无法做到实时持久化，会丢失期间数据 fork一个子进程处理保存工作，不阻塞redis bgsave在内存中每次会克隆一份数据，影响性能 2.AOF(append only file)-只追加不允许改写文件 原理:将执行的写指令记录写入到appendolny.aof文件中，重启时将aof日志文件中的指令重放。 配置:redis.conf 12345#开启aofappendonly yes(默认no)#aof生成文件名及路径appendfilename \"appendonly.aof\" 写入周期appendfsync 策略 说明 always 每次写指令就写入文件 everysec 每秒钟写入文件(默认) no 不写入文件，让操作系统来决定何时写入 重写 解决的问题:防止不断追加写入到一个aof文件，数据恢复时执行慢新的aof文件一条记录的操作只会有一次，不会记录对同一个值多次操作。 重写原理:fork一个进程，直接遍历数据，写入新的AOF临时文件。在写入新文件的过程中，所有的写操作日志还是会写到原来老的 AOF文件中，同时还会记录在内存缓冲区中。当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的 AOF文件取代老的AOF文件 AOF优劣势 优点 缺点 通过不同策略保证数据安全 重放AOF比快照慢 3.混合持久化通过快照+aof日志组合方式解决，rdb(不能实时持久化导致丢失数据)和aof(重放速度慢)的缺点，重启时先加载rdb的内容，然后再重放增量aof日志替代之前aof全量文件重放","comments":true,"tags":[{"name":"redis","slug":"redis","permalink":"http://www.caoyongjun.com/tags/redis/"}]},{"title":"csv:导出数据功能","date":"2018-10-08T07:34:00.000Z","path":"2018/10/08/csv-导出功能/","text":"csv的定义逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。 文件内容测试123标题1,标题2,标题3\"23123\",\"222.,3\",\"222,1\"\"2312321\",\"233\",\"222\" 结果 导出实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public void outPutFile()&#123; //设定第一页和每页显示1000条数 int pageNo = 1,pageSize = 1000; //获取数据库总条数 int total = mapper.countByExample(example); while ( total &gt; 0 ) &#123; //每次扣减1000,剩余数量一直循环到大于0 total = total - pageSize; //分页获取数据 int startNo = (pageNo - 1) * pageSize; example.setOrderByClause(\"id DESC LIMIT \" + startNo + \",\" + pageSize); List&lt;Object&gt; list = mapper.selectByExample(example); if ( list != null &amp;&amp; list.size() &gt; 0 ) &#123; //为了写入到外部文件中 List&lt;String&gt; dataList = new ArrayList&lt;&gt;(); //设置标题 StringBuilder sb = new StringBuilder(\"标题1,标题2,标题3\"); for ( Object obj:list )&#123; //怕内容里包含了逗号(,)所以每个内容用\\\"包裹一下免得乱了内容 sb.append(\"\\\"\").append(obj.getXXX()).append(\"\\\"\") .append(\",\") sb.append(\"\\\"\").append(obj.getYYY()).append(\"\\\"\") .append(\",\") sb.append(\"\\\"\").append(obj.getYYY()).append(\"\\\"\"); dataList.add(sb.toString()); &#125; try &#123; //文件输出全路径 File file = new File(\"C:\\\\Users\\\\win10\\\\Downloads\\\\data.csv\"); /* 第一个文件名 第二个文件字符集编码 第三个数据 第四个windows中的换行特殊符号(Linux中时\\n) 第五个是否在文件后面追加true是 */ org.apache.commons.io.FileUtils.writeLines(file, \"UTF-8\", dataList, \"\\r\\n\", true); &#125; catch (IOException e) &#123; logger.error(e.getMessage(),e); &#125; &#125; &#125;&#125;","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"csv","slug":"csv","permalink":"http://www.caoyongjun.com/tags/csv/"}]},{"title":"设计模式:2观察者模式Observer","date":"2018-09-14T07:12:00.000Z","path":"2018/09/14/design-观察者模式/","text":"定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 缺点：有多个观察者时，被通知次序有可能会乱序 主题类1234567891011121314151617181920import java.util.Observable;public class WeatherData extends Observable &#123; private int x; public void measurementsChanged()&#123; //改变Observable的changed变量为true setChanged(); notifyObservers(); &#125; public void setMeasurements(int x)&#123; this.x=x; this.measurementsChanged(); &#125; public int getX() &#123; return x; &#125;&#125; Observable类中只有在changed=true时才去通知观察者，12345678910111213141516171819protected synchronized void setChanged() &#123; this.changed = true; &#125;public void notifyObservers(Object paramObject) &#123; Object[] arrayOfObject; synchronized (this) &#123; if (!this.changed) &#123; return; &#125; arrayOfObject = this.obs.toArray(); clearChanged(); &#125; for (int i = arrayOfObject.length - 1; i &gt;= 0; i--) &#123; ((Observer)arrayOfObject[i]).update(this, paramObject); &#125; &#125; 观察者12345678910111213141516171819202122import java.util.Observable;import java.util.Observer;public class Conditions implements Observer &#123; Observable observable; private int x; public Conditions(Observable observable)&#123; this.observable=observable; observable.addObserver(this); &#125; @Override public void update(Observable obserable, Object arg1) &#123; WeatherData data=(WeatherData)obserable; this.x=data.getX(); System.out.println(\"x=\"+x); &#125;&#125; 测试类1234567public static void main(String[] args) &#123; WeatherData data=new WeatherData(); new Conditions(data); new Conditions(data); new Conditions(data); data.setMeasurements(1);&#125; 输出结果123111 注:该内容为《Head First设计模式》读后学习感悟","comments":true,"tags":[{"name":"java","slug":"java","permalink":"http://www.caoyongjun.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.caoyongjun.com/tags/设计模式/"}]},{"title":"设计模式:1策略模式Strategy","date":"2018-09-13T07:37:00.000Z","path":"2018/09/13/design-策略模式/","text":"定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 实体类1234567891011121314151617181920212223242526//出行抽象类public abstract class GoOut &#123; protected TripMode tripMode; //执行出行 public void goGo()&#123; tripMode.goOut(); &#125; //设定出行方式 public void setTripMode(TripMode tripMode) &#123; this.tripMode = tripMode; &#125;&#125;//出差类public class BusinessTrip extends GoOut &#123; public BusinessTrip()&#123; System.out.print(\"出差 \"); tripMode=new AirPlanTripMode(); &#125;&#125;//回家类public class GoHome extends GoOut &#123; public GoHome()&#123; System.out.print(\"回家 \"); tripMode=new CarTripMode(); &#125;&#125; 出行方式12345678910111213141516171819202122232425//出行方式接口public interface TripMode &#123; void goOut();&#125;//火车出行public class TrainTripMode implements TripMode &#123; @Override public void goOut() &#123; System.out.print(\" 火车 \"); &#125;&#125;//小客车出行public class CarTripMode implements TripMode &#123; @Override public void goOut() &#123; System.out.print(\" 小客车 \"); &#125;&#125;//飞机出行public class AirPlanTripMode implements TripMode &#123; @Override public void goOut() &#123; System.out.print(\" 飞机 \"); &#125;&#125; 客户端使用1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) &#123; GoOut go=new BusinessTrip(); go.goGo(); System.out.print(\" 切换 \"); go.setTripMode(new TrainTripMode()); go.goGo(); System.out.print(\" 切换 \"); go.setTripMode(new CarTripMode()); go.goGo(); System.out.println(); go=new GoHome(); go.goGo(); System.out.print(\" 切换 \"); go.setTripMode(new AirPlanTripMode()); go.goGo(); System.out.print(\" 切换 \"); go.setTripMode(new TrainTripMode()); go.goGo(); &#125;&#125; 输出结果:12出差 飞机 切换 火车 切换 小客车 回家 小客车 切换 飞机 切换 火车 应用场景： 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。 优点： 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。 注:该内容为《Head First设计模式》读后学习感悟","comments":true,"tags":[{"name":"java","slug":"java","permalink":"http://www.caoyongjun.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.caoyongjun.com/tags/设计模式/"}]},{"title":"linux安装-nginx安装","date":"2018-09-12T01:53:04.000Z","path":"2018/09/12/linux安装-nginx安装/","text":"1.解压nginx包1tar -zxvf nginx-1.9.1.tar.gz 2.安装pcre1yum install -y pcre-devel 如果安装出现在下面的错误是缺少编译环境。安装编译源码所需的工具和库12./configure: error: C compiler cc is not foundyum install gcc gcc-c++ ncurses-devel perl 3.安装cmake12yum -y install make gcc gcc-c++ ncurses-develyum -y install zlib zlib-devel 4.编译12./configure --prefix=/home/cyj/app/nginx make &amp;&amp; make install 5.启动服务1/home/cyj/app/nginx/sbin/nginx -c /home/cyj/app/nginx/conf/nginx.conf 6.如果其它机器无法访问，解决方法如下：12345/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT然后保存：/etc/rc.d/init.d/iptables save重启防火墙/etc/init.d/iptables restart 访问后如果是403就把conf的内容变为user nobody 变为 user root;","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://www.caoyongjun.com/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"http://www.caoyongjun.com/tags/nginx/"},{"name":"安装","slug":"安装","permalink":"http://www.caoyongjun.com/tags/安装/"}]},{"title":"linux安装-centOS6.5安装mysql5.7","date":"2018-09-12T01:48:04.000Z","path":"2018/09/12/linux安装-mysql安装/","text":"查看旧版本mysql 12345rpm -qa | grep -i mysql输出mysql-libs.x86_64 5.1.73-7.el6 @anaconda-CentOS-201605220104.x86_64/6.8 2.删除旧版本mysql1yum -y remove mysql-libs.x86_64 3.下载mysql1wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz 4.解压到/usr/local目录下 因为support-files/mysql.server默认位置是/usr/local/mysql不好手动修改123mv mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz /usr/local/tar -zxf mysql-5.7.17-linux-glibc2.5-x86_64.tar.gzmv mysql-5.7.17-linux-glibc2.5-x86_64 mysql 5.创建存储数据的文件1mkdir /usr/local/mysql/data 6.创建mysql用户组123456groupadd mysqluseradd mysql -g mysql#分配/usr/local/mysql的目录文件权限chown -R mysql:mysql mysql/chmod -R 755 mysql/ 7.初始化 最后一行有密码1234567[root@bogon mysql]# ./bin/mysqld --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --initialize2018-09-11T14:00:17.425754Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2018-09-11T14:00:17.814679Z 0 [Warning] InnoDB: New log files created, LSN=457902018-09-11T14:00:17.914437Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2018-09-11T14:00:17.998804Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 03b513fc-b5cb-11e8-b6c7-000c294fe2b8.2018-09-11T14:00:18.003809Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.2018-09-11T14:00:18.023285Z 1 [Note] A temporary password is generated for root@localhost: uqDvZ=kdz5gb 8.启动1./support-files/mysql.server start 9.挂软连接为了更方便使用mysql命令1ln -s /usr/local/mysql/bin/mysql /usr/bin 10.修改密码12mysql -uroot -pg%,jpMJbX1pZalter user 'root'@'localhost' identified by 'userPassword'; 11.添加可访问权限123use mysql;update user set user.Host='%' where user.User='root';flush privileges; 12.添加启动服务12ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqlchkconfig mysql on 13.如果使用客户端软件连接mysql服务出现2003错误码那就执行以下防火墙开启3306端口号12345/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT然后保存：/etc/rc.d/init.d/iptables save重启防火墙service iptables restart 14.配置文件是/usr/local/mysql/support-files/my-default.cnf","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://www.caoyongjun.com/tags/linux/"},{"name":"安装","slug":"安装","permalink":"http://www.caoyongjun.com/tags/安装/"},{"name":"mysql","slug":"mysql","permalink":"http://www.caoyongjun.com/tags/mysql/"}]},{"title":"算法:递归-归并排序","date":"2018-09-12T01:17:00.000Z","path":"2018/09/12/算法-归并排序/","text":"归并排序归并算法的中心是归并两个已经有序的数组 归并排序的思想是把一个数组分成两半，排序每一半，然后把两半归并成有序的数组 MergeSort.py结构123456789101112class MergeSort: def __init__(self,max): self.theArray=[0]*max #初始化数组 self.elements=0 #初始化数值个数 #插入操作 def _insert(self,var): self.theArray[self.elements]=var self.elements+=1 #打印数组 def _display(self): for i in range(0,self.elements): print(str(self.theArray[i])) 归并方法入口1234567891011121314151617#递归执行合并def _reMergeSort(self,workSpace,lowerBound,upperBound): #只有一个数组的值时停止递归 if lowerBound==upperBound: return else: #获取中间索引位置 mid=int((lowerBound+upperBound)/2) #递归两边的数组 _reMergeSort(workSpace,lowerBound,mid) _reMergeSort(workSpace,mid+1,upperBound) #合并两个数组操作 _merge(workSpace,lowerBound,mid+1,upperBound)#归并入口方法def _mergeSort(self): workSpace=[0]*self.elements _reMergeSort(workSpace,0,self.elements-1) 合并A数组和B数组到C数组的方法12345678910111213141516171819202122232425262728def _merge(self,workSpace,lowPtr,highPtr,upperBound): #0 j=0 lowerBound=lowPtr mid=highPtr-1 n=upperBound-lowerBound+1 #1 while lowPtr &lt;= mid and highPtr &lt;= upperBound: if self.theArray[lowPtr] &lt; self.theArray[highPtr]: workSpace[j]=self.theArray[lowPtr] j+=1 lowPtr+=1 else: workSpace[j]=self.theArray[highPtr] j+=1 highPtr+=1 #2 while lowPtr &lt;= mid: workSpace[j]=self.theArray[lowPtr] j+=1 lowPtr+=1 while highPtr &lt;= upperBound: workSpace[j]=self.theArray[highPtr] j+=1 highPtr+=1 #3 for i in range(0,n): self.theArray[lowerBound+i]=workSpace[i] 步骤 比较(如果两个数组有值的话) 复制 1 23 &lt; 7 ? 7 B-&gt;C 2 23 &lt; 14 ? 14 B-&gt;C 3 23 &lt; 39 ? 23 A-&gt;C 4 39 &lt; 47 ? 39 B-&gt;C 5 55 &lt; 47 ? 47 A-&gt;C 6 55 &lt; 81 ? 55 B-&gt;C 7 62 &lt; 81 ? 62 B-&gt;C 8 74 &lt; 81 ? 74 B-&gt;C 9 81 A-&gt;C 10 95 A-&gt;C 合并操作说明1.代码中#1功能是步骤1-8的比较方法，把AB两个数组中的值小的放入到临时数组空间上2.代码中#2功能是第8步以后没有可比较数据了就直接把剩余数据复制到C上3.代码中#3功能是把临时数组上的数据依次放入到最终的数组中 完整代码 注:该内容为Java数据结构和算法读后学习感悟 其他相关文章高级排序2-快速排序 高级排序1-希尔排序 划分排序 简单排序3-插入排序 简单排序2-选择排序 简单排序1-冒泡排序","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://www.caoyongjun.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://www.caoyongjun.com/tags/排序/"}]},{"title":"数据结构:堆","date":"2018-09-04T02:07:00.000Z","path":"2018/09/04/数据结构-堆/","text":"数据结构-堆堆是优先级队列的另一种实现结构,堆是一种数（插入和删除时间复杂度O(logN)）使用场景：速度非常重要，且有很多插入操作时，可以选择堆实现优先级队列 堆特点 完全二叉树 常常用一个数组实现 堆中的每一个节点都满足堆的条件，每一个关键字都大于或等于这个节点的子节点的关键字 用数组表示一颗树的要点，若数组中节点的索引为x则 父节点=(x-1)/2 左子节点=2x+1 右子节点=2x+2 前段时间自学了python，这次用python实现堆排序 Node.py123class Node: def __init__(self,key): self._key=key 堆结构Heap.py1234567891011121314import Nodeclass Heap: #初始化 def __init__(self,max): self._currentSize=0 self._maxSize=max self._heapArray=[0]*max #插入新节点方法省略 def insert(self,key): #删除节点方法省略 def remove(self): #改变节点值方法省略 def change(self,index,newValue); 1.插入方法 步骤： 最后一个位置添加新节点 向上跟父节点筛选比较大小，直到它在一个大于它的节点之下，小于它的节点之上 1234567891011def trickleUp(index): parentIndex=(index-1)/2 #获取新节点的父节点 bottom=self._heapArray[index] #获取刚加入的新节点 #只要没有到根节点新节点比父节点大就交换位置 while index&gt;0 and self._heapArray[parentIndex]._key&lt;bottom._key: self._heapArray[index]=self._heapArray[parentIndex] index=parentIndex parentIndex=(parentIndex-1)/2 #获取新的父节点位置 self._heapArray[index] = bottom #把新节点交换到指定位置 123456789101112def insert(self,key): if self._currentSize&gt;=self._maxSize: return False #初始化节点，设定到最后一个数组索引下 newNode=Node.Node(key) self._heapArray[self._currentSize]=newNode #向上和父节点比较大小并交换位置 self._trickleUp(self._currentSize) self._currentSize += 1 #加一 return True 2.移除方法 步骤： 移走根 把最后一个节点移动到根的位置 一直向下筛选这个节点，直到他在一个大于它的节点之下，小于它的节点之上 向下筛选的算法要检查哪一个子节点更大，然后目标节点和较大的子节点交换，否则违背了堆的条件（父节点大于子节点） 1234567891011121314151617def _trickleDown(self,index): top=self._heapArray[index] #保存最新节点 largerIndex=0 while index&lt;self._currentSize/2: #循环直到有子节点 leftChild=index*2+1 #计算左子节点索引位置 rightChild=leftChild+1 if self._heapArray[leftChild]._key&lt;self._heapArray[rightChild]._key: #比较左右节点哪个更大 largerIndex=rightChild else: largerIndex=leftChild if top._key&gt;=self._heapArray[largerIndex]._key: #找到最终位置，新节点大于等于最大子节点就退出 break self._heapArray[index]=self._heapArray[largerIndex] #交换位置 index=largerIndex self._heapArray[index]=top #新节点设值到该index 123456def remove(self): root=self._heapArray[0] #获得根节点 self._currentSize-=1; self._heapArray[0]=self._heapArray[self._currentSize] #最后一个位置索引交换到根节点位置 self._trickleDown(0) return root 3.改变节点值 改变一个已存在节点的优先级， 获取旧值 索引位置被替换为新值 比较旧值和新值如果新值大于旧值就向上筛选，否则向下筛选 12345678910111213def change(self,index,newValue): if index&lt;0 or index&gt;self._currentSize: return False oldValue=self._heapArray[index]._key #获取要被替换的旧值 self._heapArray[index]._key=newValue #设定被替换的索引值为新值 if oldValue&lt;newValue: #如果新值大于旧值就向上替换 self._trickleUp(index) else: self._trickleDown(index) #向下替换 return True 注:该内容为Java数据结构和算法读后学习感悟","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://www.caoyongjun.com/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.caoyongjun.com/tags/数据结构/"}]},{"title":"selenium:自动化迁移wiki数据","date":"2018-08-28T09:17:00.000Z","path":"2018/08/28/java-selenium-project/","text":"原由原本一直在使用第三方的在线接口文档维护着接口。最近新建立了公司内部的wiki百科为了安全性要在一周内迁移所有的showdoc文档到gitlab上。目前showdoc有将近100个文档说明，如果组内10个人一人拷贝10个也花不了太长时间，但是作为程序员还得用程序员的方式去解决重复性的活。还好刚毕业时有过类似的经历，那时也是因为wiki迁移不光有文字还有各种图片各种zip文档，大约3G不能丢失。此次迁移幸好本身的showdoc是markdown编辑的gitlab也无缝支持markdown保存，所以花了一下午的时间专门写了整个流程的selenium+java的操作。 来看一下如何去做这一套迁移工作 正常手动操作流程1.编辑要拷贝的东西 2.复制所需的文本数据 3.打开gitlab粘贴我们的数据 然后保存 整个流程手动大概5秒左右，因为来回切换复制粘贴title、目录、文本数据(如果有1万的文章那我们一个人手动大概要花5万秒) 为了把繁杂的工作变为自动化操作我们使用selenium+java来解决这个问题 使用selenium自动化操作效果（git加载慢） selenium是什么Selenium是一个用于Web应用程序测试的工具。Selenium 测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE,Mozilla和Firefox等。这个工具的主要功能包括：测试与浏览器的兼容性–测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能–创建衰退测试检验软件功能和用户需求。 利用模拟人工编辑粘贴来把需要迁移的数据迁移到新系统中。以下是具体步骤 0.把要迁移的编辑页面路径写入到文件中selenium.txt里面是精确到编辑页的路径123https://www.showdoc.cc/web/#/page/edit/110710136260844/632980917626441https://www.showdoc.cc/web/#/page/edit/110710136260844/634782624315515.....省略 1.新建一个java项目，并且加入各种依赖jar包 几个重要jar作用说明 jar名称 作用 nekohtml-1.9.21.jar 解析html的jar包 netty-3.5.2.Final.jar NIO框架,是对 socket 网络编程的包装 selenium-api-2.44.0.jar selenium的api包 selenium-chrome-driver-2.44.0.jar 谷歌浏览器驱动 selenium-firefox-driver-2.44.0.jar 火狐浏览器驱动 selenium-htmlunit-driver-2.44.0.jar selenium-ie-driver-2.44.0.jar ie浏览器驱动 selenium-java-2.44.0.jar 存在于selenium上的工具包,能有效支持java数据编程 selenium-remote-driver-2.44.0.jar 支持远程操控驱动包 selenium-safari-driver-2.44.0.jar safari浏览器驱动 selenium-support-2.44.0.jar 支持selenium的jar包 SeleniumTest-1.jar 测试包 xalan-2.7.1.jar 主要用于解析xml xercesImpl-2.11.0.jar 主要用于解析xml xml-apis-1.4.01.jar 主要用于解析xml 2.SeleniumUtil.java工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class SeleniumUtil &#123; private static WebDriver webDriver; private static WebElement webElement; private static Robot robot; private static By byelement; // 执行javascript脚本后 返回数据 public String ScriptString(String script) &#123; JavascriptExecutor js = (JavascriptExecutor) webDriver; String s = (String) js.executeScript(script); return s; &#125; /** * 初始化 * * @param select * 1:Firefox 2:IE 3:Chrome 4:后台执行 * @param browserpath * 选择本地浏览路径 */ public void Init(int switchbrowser, String browserpath) &#123; switch (switchbrowser) &#123; case 1: System.setProperty(\"webdriver.firefox.bin\", browserpath); webDriver = new FirefoxDriver(); webDriver.manage().window().maximize(); break; case 2: System.setProperty(\"webdriver.ie.driver\", browserpath); webDriver = new InternetExplorerDriver(); webDriver.manage().window().maximize(); break; case 3: System.setProperty(\"webdriver.chrome.driver\", browserpath); webDriver = new ChromeDriver(); //变大窗口 webDriver.manage().window().maximize(); break; case 4: webDriver = new HtmlUnitDriver(); break; &#125; &#125; // 复制 public static void CopyKeys() &#123; try &#123; robot = new Robot(); robot.keyPress(KeyEvent.VK_CONTROL); robot.keyPress(KeyEvent.VK_C); robot.keyRelease(KeyEvent.VK_CONTROL); robot.keyRelease(KeyEvent.VK_C); &#125; catch (AWTException e) &#123; e.printStackTrace(); &#125; &#125; // 全选 public static void AllTextKeys() &#123; try &#123; robot = new Robot(); robot.keyPress(KeyEvent.VK_CONTROL); robot.keyPress(KeyEvent.VK_A); robot.keyRelease(KeyEvent.VK_CONTROL); robot.keyRelease(KeyEvent.VK_A); &#125; catch (AWTException e) &#123; e.printStackTrace(); &#125; &#125; // 粘贴 public static void PasteKeys() &#123; try &#123; robot = new Robot(); robot.keyPress(KeyEvent.VK_CONTROL); robot.keyPress(KeyEvent.VK_V); robot.keyRelease(KeyEvent.VK_CONTROL); robot.keyRelease(KeyEvent.VK_V); &#125; catch (AWTException e) &#123; e.printStackTrace(); &#125; &#125; // 设定页面中的文本值 public static void SendKeys(By by, String value) &#123; webDriver.findElement(by).sendKeys(value); &#125; // 打开页面 public void Start(String url) &#123; webDriver.get(url); &#125; // 结束 public void Stop() &#123; webDriver.quit(); &#125; // 睡眠 public void Sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static WebDriver getWebDriver() &#123; return webDriver; &#125; public static void setWebDriver(WebDriver webDriver) &#123; SeleniumUtil.webDriver = webDriver; &#125; public static WebElement getWebElement() &#123; return webElement; &#125; public static void setWebElement(WebElement webElement) &#123; SeleniumUtil.webElement = webElement; &#125; public static By getByelement() &#123; return byelement; &#125; public static void setByelement(By byelement) &#123; SeleniumUtil.byelement = byelement; &#125;&#125; 3.业务代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package selenium.service;import java.io.File;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.io.FileUtils;import org.openqa.selenium.By;import org.openqa.selenium.WebDriver;import selenium.util.SeleniumUtil;public class CopyWiki &#123; private static SeleniumUtil util=new SeleniumUtil(); private static WebDriver driver; //showdoc用户名密码 private final static String SHOW_USERNAME=\"xxx\"; private final static String SHOW_PASSWORD=\"yyy\"; //gitlab用户名密码 private final static String GIT_USERNAME=\"xxx\"; private final static String GIT_PASSWORD=\"yyy\"; private final static String TITLE_PRE=\"接口文档/1.0/\"; //读取需要操作的目标文章 private List&lt;String&gt; readTargetUrl() throws IOException&#123; return FileUtils.readLines(new File(\"C:/Users/win10/Desktop/linux/selenium.txt\")); &#125; //打开showdoc页面 并并填写用户名密码登录 private void loginShowDoc()&#123; //登录目标网站 util.Start(\"https://www.showdoc.cc/home/user/login\"); //填写登录名 util.SendKeys(By.xpath(\"//*[@id=\\\"app\\\"]/div/section/div/div/form/div[1]/div/div/input\"), SHOW_USERNAME); //填写密码 util.SendKeys(By.xpath(\"//*[@id=\\\"app\\\"]/div/section/div/div/form/div[2]/div/div/input\"), SHOW_PASSWORD); //点击登录按钮 driver.findElement(By.xpath(\"//*[@id=\\\"app\\\"]/div/section/div/div/form/div[3]/div/button\")).click(); //等待加载页面，因为有时会没等到登录成功返回的报文 util.Sleep(1000); &#125; /** * 获取showdoc的数据 * @param url:获取数据目标url * * @return dataMap:@param * title:标题 * group:分组名 */ private Map&lt;String,String&gt; getShowDocData(String targetUrl)&#123; //打开要编辑的页面 util.Start(targetUrl); //等待加载出来数据后操作，如果文章数据多就设定长点时间 util.Sleep(3500); //获取标题 分组名 String title=driver.findElement(By.xpath(\"//*[@id=\\\"app\\\"]/div/section/div[1]/form/div[1]/div/div/input\")).getAttribute(\"value\"); String group=driver.findElement(By.xpath(\"//*[@id=\\\"app\\\"]/div/section/div[1]/form/div[3]/div/div/div[1]/input\")).getAttribute(\"value\"); //获取到文本框后 由于showdoc有jquery支持所以我用jquery脚本,但是如果没有jquery支持的网页需要用原生js来执行脚本 util.ScriptString(\"$(\\\".CodeMirror-code\\\").focus()\"); //全选编辑框 util.AllTextKeys(); //复制markdown文章 util.CopyKeys(); //设定返回值 Map&lt;String,String&gt; dataMap=new HashMap&lt;&gt;(); dataMap.put(\"title\", title); dataMap.put(\"group\", group); return dataMap; &#125; //登录gitlab 并授权登录 private void loginGitLab()&#123; //打开gitlab登录页面 util.Start(\"https://gitlab.yiqishanyuan.cn/users/sign_in\"); //登录操作 填充用户名，密码 util.SendKeys(By.xpath(\"//*[@id=\\\"user_login\\\"]\"),GIT_USERNAME); util.SendKeys(By.xpath(\"//*[@id=\\\"user_password\\\"]\"),GIT_PASSWORD); driver.findElement(By.xpath(\"//*[@id=\\\"new_user\\\"]/div[4]/input\")).click(); //等待加载页面 util.Sleep(500); &#125; /** * 写新的文章 * @param title:标题 * @param group:分组 */ private void writGitLab(String title,String group)&#123; //打开gitlab新建页面 util.Start(\"https://gitlab.yiqishanyuan.cn/v3/welfare-center/wikis/home\"); //新建页面 driver.findElement(By.xpath(\"//*[@id=\\\"content-body\\\"]/div[1]/div[2]/a[1]\")).click(); //设定新文章标题 String newTitle=TITLE_PRE+group+\"/\"+title; util.SendKeys(By.xpath(\"//*[@id=\\\"new_wiki_path\\\"]\"),newTitle); //创建页面 driver.findElement(By.xpath(\"//*[@id=\\\"modal-new-wiki\\\"]/div/div/div[2]/form/div[2]/button\")).click(); //获取到文本框后 util.ScriptString(\"$(\\\"#wiki_content\\\").focus()\"); //全选编辑框 util.AllTextKeys(); //粘贴文字 util.PasteKeys(); //点击保存 util.ScriptString(\"$(\\\"input[name='commit']\\\").click()\"); //等待保存页面 util.Sleep(1000); &#125; public static void main(String[] args) throws IOException &#123; CopyWiki copyWiki=new CopyWiki(); //1.读取之前需要拷贝的url地址 List&lt;String&gt; targetUrls=copyWiki.readTargetUrl(); if(targetUrls!=null &amp;&amp; targetUrls.size()&gt;0)&#123; //初始化chrome驱动插件执行具体的自动化操作 util.Init(3, \"C:/Program Files (x86)/Google/Chrome/Application/chromedriver.exe\"); //获取驱动 driver=util.getWebDriver(); //登录showdoc copyWiki.loginShowDoc(); //设定gitlab登录状态 copyWiki.loginGitLab(); //循环遍历 for(String targetUrl:targetUrls)&#123; //获取目标数据 Map&lt;String,String&gt; dataMap=copyWiki.getShowDocData(targetUrl); if(dataMap!=null &amp;&amp; dataMap.size()&gt;0)&#123; //新建文章，写入拷贝的数据 copyWiki.writGitLab(dataMap.get(\"title\"), dataMap.get(\"group\")); &#125; &#125; //读取后结束 util.Stop(); &#125; &#125;&#125; 4.获取页面中的节点有多种方式我这里就演示通过xpath路径获取，更多操作可以查下教程 5.最重要的干活的机器插件chromedriver.exe要对应自己的chrome浏览器下载相应的版本并且放入到自己chrome浏览器下面下载地址为chromedriver地址本次的chrome版本为v61,driver版本为v2.28 具体项目可拉取github中获取selenium-java项目","comments":true,"tags":[{"name":"java","slug":"java","permalink":"http://www.caoyongjun.com/tags/java/"},{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"selenium","slug":"selenium","permalink":"http://www.caoyongjun.com/tags/selenium/"}]},{"title":"数据结构:二叉树","date":"2018-08-28T02:55:00.000Z","path":"2018/08/28/数据结构-二叉树/","text":"数据结构-二叉树为什么使用二叉树结合了另外两种数据结构的优点 有序数组-在树中查找数据项的速度在和有序数组中查找一样快 链表-插入和删除数据项也和链表一样快 树的结构节点Node.java12345public class Node&#123; int iData; //当前值 Node leftChild; //左节点 Node rightChild; //右节点&#125; 树骨架Tree.java12345678910public class Tree&#123; private Node node; //插入某个节点 public void insert(int iData)&#123;&#125; //查找某个节点 public void find(int iData)&#123;&#125; //删除某个节点 public void delete(int iData)&#123;&#125; //省略其他方法...&#125; 1.插入方法 代码12345678910111213141516171819202122232425262728public void insert(int iData)&#123; //构造一个节点 Node newNode=new Node(); newNode.iData=iData; //如果该树为空时，直接把根节点变为该节点 if(root==null)&#123; root=newNode; &#125;else&#123; Node parent=root; //每次记录上一级节点 Node current=root; //从根节点开始遍历 while(true)&#123; parent=current; if(iData&lt;current.iData)&#123; //如果新值小于当前节点 current=current.leftChild; //就往左节点遍历 if(current==null)&#123; //左边空时 parent.leftChild=newNode; //把新节点赋值到该父级左节点 return; //退出 &#125; &#125;else&#123; current=current.rightChild; if(current==null)&#123; parent.rightChild=newNode; return; &#125; &#125; &#125; &#125;&#125; 2.插入方法 代码12345678910111213public Node find(int iData)&#123; Node current=root; //每次从根节点开始查找 while(current!=null)&#123; if(current.iData==iData)&#123; //找到了就跳出循环 break; &#125;else if(iData&lt;current.iData)&#123; //当前节点大于查找值时遍历左边孩子节点 current=current.leftChild; &#125;else&#123; current=current.rightChild; &#125; &#125; return current;&#125; 3.中序，前序，后序遍历 代码12345678910111213141516171819202122232425//中序遍历 打印的顺序时左-&gt;中-&gt;右节点顺序 public void inOrder(Node node)&#123; if(node!=null)&#123; inOrder(node.leftChild);//每次打印最左边节点 System.out.print(node.iData+\" \"); inOrder(node.rightChild); &#125;&#125;//前序遍历 打印的顺序时中-&gt;左-&gt;右节点顺序 public void preOrder(Node node)&#123; if(node!=null)&#123; System.out.print(node.iData+\" \"); preOrder(node.leftChild); preOrder(node.rightChild); &#125;&#125;//后序遍历 打印的顺序时左-&gt;右-&gt;中节点顺序 public void postOrder(Node node)&#123; if(node!=null)&#123; postOrder(node.leftChild); postOrder(node.rightChild); System.out.print(node.iData+\" \"); &#125;&#125; 输出1 2 3 4 5 6 7 8 9 10 11 12 15 16 中序5 1 2 3 4 6 7 8 9 10 11 12 15 16 前序1 2 3 4 6 7 8 9 10 11 12 15 16 5 后序 4.删除目标节点 有多少子节点 删除步骤 无子节点 直接删除该节点即可 一个子节点 判断删除节点的子节点剩下的是左还是右，然后把删除的子节点挂到父节点的左或者右节点 两个子节点 1.找后继节点(继承被删除节点的位置)，默认是删除节点的右节点 2.找新后继节点-循环遍历默认后继节点的左节点 3.交换后继节点和删除节点的位置，后继节点的左节点变为null,删除节点的右节点变为删除节点的右节点 寻找要删除的节点代码12345678910111213141516171819202122232425262728293031323334353637383940public boolean findDeleteNode(int iData)&#123; if(root==null)&#123; //如果没有数据就返回false return false; &#125; Node parent=root; Node current=root; boolean isLeftChild=false; //寻找要删除的节点 while(current.iData!=iData)&#123; //一直循环到找到删除的节点 parent=current; if(iData&lt;current.iData)&#123; isLeftChild=true; current=current.leftChild; if(current==null)&#123; //找不到删除节点时跳出循环 break; &#125; &#125;else&#123; isLeftChild=false; current=current.rightChild; if(current==null)&#123; break; &#125; &#125; &#125; if(current==null)&#123;//没找到要删除的节点 return false; &#125; //删除节点无子节点时 if(current.leftChild==null &amp;&amp; current.rightChild==null)&#123; deleteNoneChild(parent,current,isLeftChild); &#125;else if(current.leftChild==null)&#123; deleteOneChild(parent,current,current.rightChild,isLeftChild); &#125;else if(current.rightChild==null)&#123; deleteOneChild(parent,current,current.leftChild,isLeftChild); &#125;else&#123; deleteTwoChild(parent,current,isLeftChild); &#125; return true;&#125; 1.删除节点无子节点时 123456789private void deleteNoneChild(Node parent,Node delNode,boolean isLeftChild)&#123; if(delNode==root)&#123; root=null; &#125;else if(isLeftChild)&#123; //如果删除节点是左节点，就把父节点的左节点变为null parent.leftChild=null; &#125;else&#123; parent.rightChild=null; &#125;&#125; 2.删除节点有一个子节点时 123456789private void deleteOneChild(Node parent,Node delNode,Node childNode,boolean isLeftChild)&#123; if(delNode=root)&#123; root=childNode; &#125;else if(isLeftChild)&#123; parent.leftChild=childNode; &#125;else&#123; parent.rightChild=childNode; &#125;&#125; 3.删除节点有两个子节点时 删除逻辑1234567891011public void deleteTwoChild(Node parent,Node delNode,boolean isLeftChild)&#123; Node successor=getSuccessor(delNode); //获取后继节点 if(delNode==root)&#123; root=successor; &#125;else if(isLeftChild)&#123; //挂靠父节点的左边位置 parent.leftChild=successor; &#125;else&#123; parent.rightChild=successor; &#125; successor.leftChild=delNode.leftChild; //后继节点的左节点变为删除节点的左节点&#125; 获取后继节点逻辑 后继节点的右节点变为删除节点的右节点，并且和删除节点调换位置1234567891011121314151617public Node getSuccessor(Node delNode)&#123; Node successorParent=delNode; //后继节点父级初始值 Node successor=delNode; //后继节点初始值 Node current=delNode.rightChild; //由于已经判断了有两个子节点了，第一默认后继节点就是右子节点 while(current!=null)&#123; //一直循环查找后继节点-&gt;查找最左子节点 successorParent=successor; successor=current; current=current.leftChild; &#125; if(successor!=delNode.rightChild)&#123; //如果后继节点不是删除节点的右节点，那就可判断后继节点是最左节点 successorParent.leftChild=successor.rightChild; //父级左节点变为后继右节点(其实就null) successor.rightChild=delNode.rightChild; //后继右节点变为删除节点的右节点 &#125; return successor;&#125; 注:该内容为Java数据结构和算法读后学习感悟","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://www.caoyongjun.com/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.caoyongjun.com/tags/数据结构/"}]},{"title":"算法:高级排序2-快速排序","date":"2018-08-22T02:55:00.000Z","path":"2018/08/22/算法-快速排序/","text":"高级排序2-快速排序 思路 0.每次执行前判断要排序的目标数组长度是否小于等于三，如果小那就不去执行快速排序，而是三个值交换位置即可。 1.每次选择三个值排序这三值是(第一个位置，中间位置，最后一个位置)。 2.选择中间位置作为枢纽，并把它的值交换到倒数第二个位置。 3.进行划分算法获得被划分的索引位置 3.1.左扫描从第二个位置开始把所有小于枢纽值的交换到扫描索引那里。 3.2.同时进行右扫描从倒数第三个位置(因为倒数第一个已经是大于枢纽，倒数第二个是枢纽)，所有大于枢纽值的交换到扫描索引位置。 3.3.一直扫描到左右索引交替时把枢纽值(倒数第二个位置的值)交换到左扫描索引位置，并返回划分位置。 4.获得划分位置后得到左右两个子数组，左边是0到划分索引-1位置，右边是划分索引+1到数组末端，继续从0步骤开始递归操作。 QuickSort.java 具体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class QuickSort &#123; static long array[]=new long[]&#123;9,5,4,55,16,115,200,10,8,6,22,44,1,2,3,0,7,12,13,20,50,44,31&#125;; //交换索引值 static void swap(int i,int j)&#123; long temp=array[i]; array[i]=array[j]; array[j]=temp; &#125; static void print()&#123; for(int i=0;i&lt;array.length;i++)&#123; System.out.print(array[i]+\" \"); &#125; &#125; //小于等于三时手动排序三个值 static void manualSort(int left,int right,int size)&#123; if(size&lt;=1)&#123; return; &#125;else if(size==2)&#123; if(array[left]&gt;array[right])&#123; swap(left,right); &#125; &#125;else&#123; if(array[left]&gt;array[right])&#123; swap(left,right); &#125; if(array[left]&gt;array[right-1])&#123; swap(left,right-1); &#125; if(array[right-1]&gt;array[right])&#123; swap(right-1,right); &#125; &#125; &#125; //获取枢纽值作为划分，并把该枢纽值交换到倒数第二个位置 static long getPivot(int left,int right)&#123; int center=(right+left)/2; if(array[left]&gt;array[center])&#123; swap(left,center); &#125; if(array[left]&gt;array[right])&#123; swap(left,right); &#125; if(array[center]&gt;array[right])&#123; swap(center,right); &#125; long pivot=array[center]; swap(center,right-1); return pivot; &#125; //获取划分索引位置 static int getPartitionIndex(int left,int right,long pivot)&#123; int leftScan=left; int rightScan=right-1; while(true)&#123; while(array[++leftScan]&lt;pivot); while(array[--rightScan]&gt;pivot); if(leftScan&gt;=rightScan)&#123; break; &#125;else&#123; swap(leftScan,rightScan); &#125; &#125; swap(leftScan,right-1); return leftScan; &#125; static void quickSort(int left,int right)&#123; int size=right-left+1; //1 if(size&lt;=3)&#123; manualSort(left,right,size); &#125;else&#123; long pivot=getPivot(left,right); //2 int partitionIndex=getPartitionIndex(left,right,pivot); //3 quickSort(left,partitionIndex-1); //4 quickSort(partitionIndex+1,right); &#125; &#125; public static void main(String[] args) &#123; quickSort(0,array.length-1); print();//打印输出排序好的值 &#125;&#125; 输出： 0 1 2 3 4 5 6 7 8 9 10 12 13 16 20 22 31 44 44 50 55 115 200 说明 1.计算要排序的数组长度如果小于等于3就手动排序值不去进行下一步骤排序，大于3时进行划分。 2.获取三个值(最左，最右，中间索引)的中间值，并排序三个值，把枢纽值交换到倒数第二个索引上。 3.划分算法，并获得划分索引位置，把所有小于枢纽值放在左边，大于枢纽值放到右边，并把枢纽值交换到划分索引位置。 4.划分左右两个子数组重复递归 注:该内容为Java数据结构和算法读后学习感悟 其他相关文章递归-归并排序 划分排序 高级排序1-希尔排序 简单排序3-插入排序 简单排序2-选择排序 简单排序1-冒泡排序","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://www.caoyongjun.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://www.caoyongjun.com/tags/排序/"}]},{"title":"linux-shell单引号双引号","date":"2018-08-16T09:56:00.000Z","path":"2018/08/16/linux-shell单引号双引号/","text":"符号 识别命令 识别变量 间隔号 √ √ 双引号 × √ 单引号 × × 具体结果以下脚本输出内容 123456789101112131415161718url=caoyongjun.com#内容太长所以截取到50位后输出var=`curl http://$url`substring=$&#123;var:0:50&#125;echo $substringecho \"============间隔号识别命令和变量\"echo \"curl http://$url\"echo \"============双引号不识别命令，但变量\"echo 'curl http://$url'echo \"============单引号不识别变量和命令\" 结果 &lt;!DOCTYPE html&gt; &lt;meta charset=”utf============间隔号识别命令和变量curl http://caoyongjun.com============双引号不识别命令，但变量curl http://$url============单引号不识别变量和命令","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://www.caoyongjun.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://www.caoyongjun.com/tags/shell/"}]},{"title":"算法:划分","date":"2018-08-14T09:45:00.000Z","path":"2018/08/14/算法-划分/","text":"划分是快速排序的根本机制。原理-把数组分为两组，使所有的值大于特定值的数据项的在一组，所有小于特定值的在一组。 SortUtils.java 主要完成换位和打印任务，在之后的简单排序中都会用此工具类 12345678910111213141516171819202122public class SortUtils &#123; /** * @param array=数组 * @param index=当前位置 * @param next=下一个位置 */ public static void swap(int[] array,int index,int next)&#123; int tmp=array[index]; array[index]=array[next]; array[next]=tmp; &#125; /** * @param array=要打印的数组 */ public static void display(int[] array)&#123; for(int i=0;i&lt;array.length;i++)&#123; System.out.print(\" \"+array[i]); &#125; &#125;&#125; Partition.java 具体实现 12345678910111213141516171819202122232425262728public class Partition &#123; public static int array[]=&#123;1,222,33,45, 5, 2,332,44,87,1,2,0,33,55, 3,4&#125;; public static void sort(int minIndex,int maxIndex,int pivot)&#123; int leftPar=minIndex-1,rightPar=maxIndex+1; //1 while(true)&#123; //2 while(leftPar&lt;maxIndex &amp;&amp; array[++leftPar]&lt;pivot); //3 while(rightPar&gt;minIndex &amp;&amp; array[--rightPar]&gt;pivot); //4 if(leftPar&gt;=rightPar)&#123; //5 break; &#125;else&#123; SortUtils.swap(leftPar,rightPar); //6 &#125; &#125; &#125; public static void main(String[] args) &#123; int pivot=40;//特定值 //传入最左索引位置，和最右索引位置 sort(0,array.length-1,pivot); SortUtils.display(array);//打印排序好的数据 &#125;&#125; 输出：1 4 33 3 5 2 33 0 2 1 87 44 332 55 45 222 说明 1.这里把leftPar变为小于0,rightPar变为大于总长度的原因是为了在位置3和位置4那里做++和- -操作 2.一直执行到最左索引和最右端索引重合或者大于最右端索引 3.左索引小于最大索引并且值小于特定值时一直向右比较大小 4.右索引大于数组最小索引并且大于特定值时一直向左比较大小 5.两端索引重合或者左大于右时跳出循环 6.交换位置 注:该内容为Java数据结构和算法读后学习感悟 其他相关文章递归-归并排序 高级排序2-快速排序 高级排序1-希尔排序 简单排序3-插入排序 简单排序2-选择排序 简单排序1-冒泡排序","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://www.caoyongjun.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://www.caoyongjun.com/tags/排序/"}]},{"title":"RESTFUL接口风格","date":"2018-08-01T04:14:18.000Z","path":"2018/08/01/RESTFUL接口风格/","text":"RESTFUL(Representational state transfer)对统一资源定位符(URL)的表现层状态转移 1.资源所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URL就可以，因此URL就成了每一个资源的地址或独一无二的识别符。 2.表现层“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。URL只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URL应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 3.状态转化访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 RESTFull优点 轻量，直接基于http，不在需要任何别的诸如消息协议。get/post/put/delete为CRUD操作 面向资源，一目了然，具有自解释性。 数据描述简单，一般以xml，json做数据交换。 注意1.URL不能包含动词，要用名词表示资源所在位置 2.请求方法由4个方法来请求 3.请求路径尽量是用数据库表名定义 HTTP标准方法 方法 安全性 幂等性 用途 get √ √ 从服务器取出资源（一项或多项） post × × 在服务器新建一个资源 put × √ 在服务器更新资源（客户端提供改变后的完整资源） delete × √ 从服务器删除资源 URL用到的标识符 标识符 说明 例子 -或_ 用来分隔单词 http://xyz.com/goods-center http://xyz.com/goods_center / 资源的层级关系 ? 过滤资源请求 http://xyz.com/goods-center/goods?pageNo=1&amp;pageSize=10 ,或; 表示同级资源关系 http://xyz.com/goods-center/goods/11,22,33 实际例子12345678910111213141516171819202122232425262728@RequestMapping(value = \"/property/manage\")public class PropertyController &#123; //1.插入 @PostMapping public CommonVO insertProperty(@RequestBody PropertyBO property) //2.删除 @DeleteMapping(\"/&#123;id&#125;\") public CommonVO deleteProperty(@PathVariable(value = \"id\", required = true) String id) //5.列表 必须在getMapping&#123;id&#125;前面否则被拦截 @GetMapping public CommonVO listProperty(@RequestParam(value = \"name\", required = false) String name, @RequestParam(value = \"pageNo\", required = false) Integer pageNo, @RequestParam(value = \"pageSize\", required = false) Integer pageSize) //3.详情 @GetMapping(\"/&#123;id&#125;\") public CommonVO getProperty(@PathVariable(value = \"id\", required = true) String id) //4.修改 @PutMapping(\"/&#123;id&#125;\") public CommonVO updateProperty(@PathVariable(value = \"id\", required = true) String id ,@RequestBody PropertyBO property) &#125;","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"}]},{"title":"商品开发4-商品存储展示","date":"2018-07-17T09:45:22.000Z","path":"2018/07/17/商品开发4-商品存储展示/","text":"拉平商品相关联的所有表字段到一张大而全的mongodb中拉平商品数据 由于商品关联的表太多，mysql join多表查询时会很慢。相关缺点参考此人写的join缺点。 释放商品mysql的查询压力，mysql只负责商品的增删改的事务类操作，更多使用mongodb来做列表查询操作，redis(hash结构)缓存商品详情。 mongo存储商品数据维度为商品级别 redis存储商品数据维度为sku级别 定时同步商品数据 定时任务记录上次更新时间到当前时间的商品信息同步到mongo和redis中，并用redis的key来记录 查询上次同步时间，如果没有就查询整个的商品编辑时间到当前时间的数据同步到mongo和redis 如果有上次同步时间，就执行sql语句lastAt&lt;=update_at AND update_at&lt;=now()得到同步商品 记录当前时间，并放入redis中变为lastAt 定时把redis中的商品sku库存，销量同步到mysql的eb_goods_sku中 编辑商品时如果把sku删除了就要马上执行同步把redis的sku库存销量等信息同步到mysql，不然会丢失数据 展示商品数据 查询列表直接到mongo查询，查出后库存要到对应的redis中查找 查询某一个商品时去redis中查找该商品下面的所有已启用的skuId后对应单个查找redis详情 扣减库存 利用redis的increment保证了线程安全，每次扣减变为负数时要补偿回滚库存。 其他相关文章商品开发3-商品上新时流程 商品开发2-表之间关系 商品开发1-数据库设计","comments":true,"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"},{"name":"商品模块","slug":"商品模块","permalink":"http://www.caoyongjun.com/tags/商品模块/"}]},{"title":"商品开发3-商品上新时流程","date":"2018-07-17T07:32:22.000Z","path":"2018/07/17/商品开发3-商品上新时流程/","text":"分类管理 匹配往分类中下挂属性 每个分类可继承某个分类的所有属性 分别使用{“is_must”:”是否必填”,”is_sale”:”是否生成sku”,”is_can_new”:”是否支持自定义输入值”}来指定属性的功能 上新商品流程1.选择某一个分类 拿到eb_species的species_id 去查eb_species_property表，找到对应的property_id列表 2.获得具体分类的属性表 遍历eb_property获得属性类型 遍历eb_property_value获得属性对应的属性值列表 3.校验必填的属性是否为有遗漏 is_must的属性不能空值 4.匹配各自数据分别插入到对应的表中 属性判断是否为销售属性(is_sale=1时为销售属性) 把is_sale=1的属性值放入到eb_goods_sku_value中 把is_sale=0的基本属性信息放入到eb_goods_property中 5.后台删除某个属性时 对应eb_species_property表中的property_id删除 对应eb_property表中的property_id删除 对应eb_property_value表中的property_id删除 不改动eb_goods_property表 不改动eb_goods_sku_value表 所以插入到eb_goods_property和eb_goods_sku_value时要把大而全的信息都放入，免得属性被删时显示不了数据 其他相关文章商品开发4-商品存储展示 商品开发2-表之间关系 商品开发1-数据库设计","comments":true,"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"},{"name":"商品模块","slug":"商品模块","permalink":"http://www.caoyongjun.com/tags/商品模块/"}]},{"title":"商品开发2-表之间关系","date":"2018-07-17T03:12:22.000Z","path":"2018/07/17/商品开发2-表之间关系/","text":"商品表(eb_goods) 主要存储商品的公共信息，列如商品名称、商品描述、商品主图、轮播图等。 商品sku表(eb_goods_sku) 主要存储每个商品规格的库存、价格、编号、sku图片、销量等。(eb_goods)1:m(eb_goods_sku)。 商品sku值表(eb_goods_sku_value) 主要存储哪些属性组合在一起时确定为某一个sku编号来确定商品价格。(eb_goods_sku)1:m(eb_goods_sku_value)。 商品属性表(eb_goods_property) 主要存储商品的除销售属性外的基本属性(如:产地、是否实体商品、扔摔高度等)。(eb_goods)1:m(eb_goods_property)。 属性表(eb_property) 存储属性信息，用来存储商品要用到的各种属性信息，类型多样化(0:不用选择，1:输入框，2:单选，3:多选，4:下拉文本，5:上传文件，6:时间，7:产地)。 属性值表(eb_property_value) 存储属性具体选项的值表，比如属性类型是单选时，它的属性值有是或者否选项供用户选择。(eb_goods_property)1:m(eb_goods_property_value)。 分类表(eb_species) 存储分类信息。 分类属性表(eb_species_property) 主要匹配分类和哪些属性挂钩，并且在这里设定哪些属性是作为必填项(is_must)、还是销售属性(is_sale)、还是可以手动添加自定义值(is_can_new)，主要用于在商品上新时与某个分类挂钩后对应哪些需要必须录入值、哪些要插入到商品sku属性表中。 其他相关文章商品开发4-商品存储展示 商品开发3-商品上新时流程 商品开发1-数据库设计","comments":true,"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"},{"name":"数据库设计","slug":"数据库设计","permalink":"http://www.caoyongjun.com/tags/数据库设计/"},{"name":"商品模块","slug":"商品模块","permalink":"http://www.caoyongjun.com/tags/商品模块/"}]},{"title":"商品开发1-数据库设计","date":"2018-07-17T02:56:22.000Z","path":"2018/07/17/商品开发1-数据库设计/","text":"商品最为核心的就是如何确定某一个商品的规格的价格和此规格的库存，所以合理设计sku是商品模块的重点首先百度中的sku的定义1SKU=Stock Keeping Unit（库存量单位）。即库存进出计量的基本单元，可以是以件，盒，托盘等为单位。SKU这是对于大型连锁超市DC（配送中心）物流管理的一个必要的方法。现在已经被引申为产品统一编号的简称，每种产品均对应有唯一的SKU号。单品：对一种商品而言，当其品牌、型号、配置、等级、花色、包装容量、单位、生产日期、保质期、用途、价格、产地等属性中任一属性与其他商品存在不同时，可称为一个单品。 1.商品表 eb_goods 之后所有表省略 is_delete,create_at,create_id,update_at,update_id 以及隐藏所有非关键的字段 字段 类型 说明 goods_id varchar(32) 商品主键 goods_name varchar 商品名称 goods_desc text 产品描述 is_delete int 是否 1:删除,0:可用 create_at timestamp 创建时间 create_id varchar 创建人id update_at timestamp 更新时间 update_id varchar 更新人id 2.商品sku表 eb_goods_sku 字段 类型 说明 sku_id varchar(32) sku主键 goods_id varchar(32) 产品主键 stocks int(11) 数量 price bigint(20) 价格 origin_price bigint(20) 原价 sku_name varchar(45) sku名称 sku_code varchar(45) 商品编码（第三方的） sku_status int(11) 启用 1 未启用0 img_url varchar(1000) sku的图片 is_default int(11) 是否是默认sku sale_num bigint(20) 销量 3.商品sku值表 eb_goods_sku_value 字段 类型 说明 sku_value_id varchar(32) sku值主键 sku_id varchar(32) 商品sku主键 property_id varchar(32) 类属性主键 property_name varchar(45) 属性名 property_value_id varchar(32) 类属性值主键 property_value_name varchar(1000) 有可能是多个认证时 map转成json存储 sku_value varchar(45) 具体值 5.商品媒体表 eb_goods_media 字段 类型 说明 goods_media_id varchar(32) 媒体主键 goods_id varchar(32) 商品主键 type int(11) 媒体类型 1图片，2视频 position int(11) 显示的具体位置 0 主图 ，1轮播图，2内容图 img_url varchar(1000) 图片地址 idx int(11) 排序字段 默认0 status int(11) 1 显示 0 不显示 视频上传后可能不想要显示时 0 video_url varchar(100) 视频路径 6.商品属性表 eb_goods_property 字段 类型 说明 goods_property_id varchar(32) 商品属性主键 goods_id varchar(32) 商品主键 property_id varchar(32) 类属性主键 property_name varchar(45) 属性名 property_value_id varchar(32) 类属性值id property_value_name varchar(1000) 有可能是多个认证时 map转成json存储 8.属性表 eb_property 字段 类型 说明 property_id varchar(32) 产品分类属性主键 name varchar(45) 属性名称 property_desc varchar(100) 属性描述 type int(11) 属性类型 type=0:不用选择,1:输入框,2:单选,3:多选,4:下拉文本,5:上传文件,6:时间,7:产地,8:包装单位 type_value varchar(20) 类型值,属性类型 type=1:输入框{10:常规,11:整数,12:小数},6:时间{60:不影响下架,61:影响下架} 9.属性值表 eb_property_value 字段 类型 说明 property_value_id varchar(32) 类目属性值主键 property_id varchar(32) 属性主键 value_name varchar(255) 属性值名称 有可能是图片路径 idx int(11) 排序 13.分类表 eb_species 字段 类型 说明 species_id varchar(32) 分类主键 name varchar(45) 分类名称 parent_id varchar(32) 父id species_desc varchar(100) 分类描述 14.分类属性表 eb_species_property 字段 类型 说明 species_property_id varchar(32) 产品分类属性主键 species_id varchar(32) 分类主键 property_id varchar(32) 属性主键 property_desc varchar(100) 属性描述 is_sale int(11) 是否销售属性 1是 is_must int(11) 是否必选 1是 is_can_new int(11) 上架是否可以手动新建值 其他相关文章商品开发4-商品存储展示 商品开发3-商品上新时流程 商品开发2-表之间关系","comments":true,"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"},{"name":"数据库设计","slug":"数据库设计","permalink":"http://www.caoyongjun.com/tags/数据库设计/"},{"name":"商品模块","slug":"商品模块","permalink":"http://www.caoyongjun.com/tags/商品模块/"}]},{"title":"mongo-springmvc+spring data mongo配置","date":"2018-05-30T08:46:00.000Z","path":"2018/05/30/mongo-springmvc+spring-data-mongo/","text":"1.导入必要包pom.xml12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt; &lt;version&gt;1.8.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2.applicationContext.xml引入mongo-content.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;import resource=\"applicationContext-config.xml\"/&gt; &lt;import resource=\"applicationContext-dao.xml\"/&gt; &lt;import resource=\"applicationContext-service.xml\"/&gt; &lt;!--导入mongodb的配置文件--&gt; &lt;import resource=\"mongodb-context.xml\"/&gt; &lt;import resource=\"redis-context.xml\"/&gt; &lt;/beans&gt; 3.mongodb-content.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mongo=\"http://www.springframework.org/schema/data/mongo\" xsi:schemaLocation=\"http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/data/mongo http://www.springframework.org/schema/data/mongo/spring-mongo-1.0.xsd\"&gt; &lt;context:property-placeholder location=\"classpath:config.properties\"/&gt; &lt;!-- 只有这个版本spring-mongo-1.0.xsd采用mongo其他版本不支持 mongo:mongo --&gt; &lt;mongo:mongo id=\"mongo\" replica-set=\"$&#123;mongo.hostport&#125;\"&gt; &lt;!-- 一些连接属性的设置 --&gt; &lt;mongo:options connections-per-host=\"$&#123;mongo.connectionsPerHost&#125;\" threads-allowed-to-block-for-connection-multiplier=\"$&#123;mongo.threadsAllowedToBlockForConnectionMultiplier&#125;\" connect-timeout=\"$&#123;mongo.connectTimeout&#125;\" max-wait-time=\"$&#123;mongo.maxWaitTime&#125;\" auto-connect-retry=\"$&#123;mongo.autoConnectRetry&#125;\" socket-keep-alive=\"$&#123;mongo.socketKeepAlive&#125;\" socket-timeout=\"$&#123;mongo.socketTimeout&#125;\" slave-ok=\"$&#123;mongo.slaveOk&#125;\" write-number=\"1\" write-timeout=\"0\" write-fsync=\"true\"/&gt; &lt;/mongo:mongo&gt; &lt;!-- mongo的工厂，通过它来取得mongo实例,dbname为mongodb的数据库名，没有的话会自动创建 --&gt; &lt;mongo:db-factory dbname=\"$&#123;mongo.database&#125;\" mongo-ref=\"mongo\"/&gt; &lt;!-- 用户名密码验证 --&gt; &lt;bean id=\"userCredentials\" class=\"org.springframework.data.authentication.UserCredentials\"&gt; &lt;constructor-arg name=\"username\" value=\"$&#123;mongo.username&#125;\" /&gt; &lt;constructor-arg name=\"password\" value=\"$&#123;mongo.password&#125;\" /&gt; &lt;/bean&gt; &lt;bean id=\"mongoTemplate\" class=\"org.springframework.data.mongodb.core.MongoTemplate\"&gt; &lt;constructor-arg ref=\"mongo\"/&gt; &lt;constructor-arg name=\"databaseName\" value=\"$&#123;mongo.database&#125;\"/&gt; &lt;constructor-arg name=\"userCredentials\" ref=\"userCredentials\" /&gt; &lt;/bean&gt; &lt;!-- 映射转换器，扫描back-package目录下的文件，根据注释，把它们作为mongodb的一个collection的映射 --&gt; &lt;mongo:mapping-converter base-package=\"com.hold.third.mongo.model\"/&gt; &lt;!-- mongodb bean的仓库目录，会自动扫描扩展了MongoRepository接口的接口进行注入 --&gt; &lt;mongo:repositories base-package=\"com.hold.third.mongo.repository\"/&gt;&lt;/beans&gt; 4.config.properties1234567891011121314151617#mongoDB连接配置 mongo.hostport=$&#123;mongo.hostport&#125;mongo.connectionsPerHost=8mongo.threadsAllowedToBlockForConnectionMultiplier=4#连接超时时间 mongo.connectTimeout=1000#等待时间 mongo.maxWaitTime=1500mongo.autoConnectRetry=truemongo.socketKeepAlive=true#Socket超时时间 mongo.socketTimeout=1500mongo.slaveOk=true#数据库名称 mongo.database=$&#123;mongo.database&#125;mongo.username=$&#123;mongo.username&#125;mongo.password=$&#123;mongo.password&#125; 5.mongo类ContentMG.class1234567891011121314151617181920212223242526272829package com.hold.third.mongo.model;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.mapping.Document; @Document(collection = \"content\") public class ContentMG &#123; @Id private String id; private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 6.使用mongo保存和查询12345678910111213141516171819@Autowiredprivate MongoTemplate template; public Map&lt;String, Object&gt; testMongo(String content) &#123; Map&lt;String, Object&gt; dataMap = new HashMap&lt;String, Object&gt;(); //保存 ContentMG mg=new ContentMG(); mg.setId(RandomIdUtil.getRandomCode()); mg.setContent(content); template.save(mg); //查询 Query query=new Query(); Criteria c=new Criteria(); c.and(\"content\").is(\"1\"); query.addCriteria(c); dataMap.put(\"list\", template.find(query, ContentMG.class)); return dataMap; &#125;","comments":true,"tags":[{"name":"mongo","slug":"mongo","permalink":"http://www.caoyongjun.com/tags/mongo/"},{"name":"springmvc","slug":"springmvc","permalink":"http://www.caoyongjun.com/tags/springmvc/"}]},{"title":"mongo-linux安装配置","date":"2018-05-30T07:10:00.000Z","path":"2018/05/30/mongo-linux配置/","text":"1.下载mongo1curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz 2.解压mongo1tar -zxvf mongodb-linux-x86_64-3.0.6.tgz 3.移到指定目录后给一个软链接123mv mongodb-linux-x86_64-3.0.6 /root/apps/cd /root/appsln -s /root/apps/mongodb-linux-x86_64-3.0.6 mongo 4.写入到系统变量中方便使用12vi /etc/profileexport PATH=&lt;mongodb-install-directory&gt;/bin:$PATH ==&gt; export PATH=/root/apps/mongo/bin:$PATH 5.创建数据库存储目录data1mkdir -p /root/apps/mongo/data/db 6.加上权限 123456789use admindb.createUser( &#123; user: \"adminUser\", pwd: \"adminPass\", roles: [ &#123; role: \"userAdminAnyDatabase\", db: \"admin\" &#125; ] &#125;) 6.1.启动校验验证1mongod --auth --port 27017 --dbpath /root/apps/mongo/data/db1 6.1.1.第一种指定用户名和密码库1mongo --port 27017 -u \"adminUser\" -p \"adminPass\" --authenticationDatabase \"admin\" 6.1.2.第二种连接库后1234mongo --port 27017use admindb.auth(\"adminUser\", \"adminPass\") 7.创建普通用户123456789use foodb.createUser( &#123; user: \"foo\", pwd: \"foo\", roles: [ &#123; role: \"readWrite\", db: \"foo\" &#125; ] &#125;) 8.角色定义 键 说明 read 允许用户读取指定数据库 readWrite 允许用户读写指定数据库 dbAdmin 允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile userAdmin 允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户 clusterAdmin 只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限 readAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的读写权限 userAdminAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的userAdmin权限 dbAdminAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限 root 只在admin数据库中可用。超级账号，超级权限","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://www.caoyongjun.com/tags/linux/"},{"name":"mongo","slug":"mongo","permalink":"http://www.caoyongjun.com/tags/mongo/"}]},{"title":"算法:高级排序1-希尔排序","date":"2018-03-19T02:58:00.000Z","path":"2018/03/19/算法-希尔排序/","text":"高级排序1-希尔排序 思路 1.在插入排序的基础下只用增量减量的方式 2.最后一步减量后序列为1,执行普通的插入排序 ShellSort.java 具体实现 1234567891011121314151617181920212223242526272829public class ShellSort &#123; public static int array[] = &#123; 4, 21, 2, 4, 6, 88, 9, 11, 2, 45, 7, 8, 12, 22, 33, 44, 1, 2, 33, 44, 55, 7, 11, 12, 10 &#125;; public static void main(String[] args) &#123; int out, in, temp; int h = 1; while (h &lt;= array.length / 3) &#123; //1 h = h * 3 + 1; &#125; while (h &gt; 0) &#123; //2 for (out = h; out &lt; array.length; out++) &#123; temp = array[out]; in = out; while (in &gt; h - 1 &amp;&amp; array[in - h] &gt; temp) &#123; //3 array[in] = array[in - h]; in -= h; //4 &#125; array[in] = temp; //5 &#125; h = (h - 1) / 3; //6 &#125; &#125;&#125; 输出： 1 2 2 2 4 4 6 7 7 8 9 10 11 11 12 12 21 22 33 33 44 44 45 55 88 说明 1.增量{1,4,13,40,121,364,1093…} 2.减量一直到等于1为止 3.找到自己的之前增量的位置比较大小 4.减量 5.插入该位置 6.减量{…1093,364,121,40,13,4,1} 注:该内容为Java数据结构和算法读后学习感悟 其他相关文章递归-归并排序 高级排序2-快速排序 划分排序 简单排序3-插入排序 简单排序2-选择排序 简单排序1-冒泡排序","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://www.caoyongjun.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://www.caoyongjun.com/tags/排序/"}]},{"title":"linux-shell判断语句","date":"2018-03-18T06:29:04.000Z","path":"2018/03/18/linux-shell判断语句/","text":"规范有点严格 if空格[空格”xx”空格=空格”xx”空格];空格then echo “if” elif空格[空格”xx”空格=空格”xx”空格];空格then echo “elseif” else echo “else” fi 1234567891011121314if [ \"xx\" = \"xx\" ]; thenecho \"if\"elif [ \"xx\" = \"xx\" ]; thenecho \"elseif\"elseecho \"else\"fi","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://www.caoyongjun.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://www.caoyongjun.com/tags/shell/"}]},{"title":"算法:简单排序3-插入排序","date":"2018-03-18T05:42:00.000Z","path":"2018/03/18/算法-插入排序/","text":"简单排序3-插入排序 思路 1.每一次循环从第二位置开始，并把第二个位置空出来，把数放到临时的地方 2.依次和空白位置的左侧比较大小 3.如果比左侧小就继续向左比较大小，同时左侧的数量依次向空白处移动位置 InsertSort.java 具体实现 12345678910111213141516171819202122232425public class InsertSort &#123; public static int array[] = &#123; 5, 6, 3, 1, 3 &#125;; public static void main(String[] args) &#123; for (int out = 1; out &lt; array.length; out++) &#123; //1 int in = out; //2 int temp = array[out]; //3 while (in &gt; 0 &amp;&amp; array[in - 1] &gt; temp) &#123; //4 array[in] = array[in - 1]; //5 --in; &#125; array[in] = temp; //6 &#125; for(int i=0;i&lt;array.length;i++)&#123; System.out.print(\" \"+array[i]); &#125; &#125;&#125; 输出： 1 3 3 5 6 说明 1.从第二个位置开始循环 2.里层下标记录为out 3.把第二个位置挪出到临时区域，并变为空白位置 4.向左侧一直比较大小，直到没有可比较的，当有比抽离出来的位置大于的数时进行交换位置 5.依次向右移动到空白位置 6.把临时区的数据插入到符合位置 注意：逆序时的插入排序比冒泡还要慢，因为每一次都会产生比较和交换位置。 注:该内容为Java数据结构和算法读后学习感悟 其他相关文章递归-归并排序 高级排序2-快速排序 划分排序 高级排序1-希尔排序 简单排序2-选择排序 简单排序1-冒泡排序","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://www.caoyongjun.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://www.caoyongjun.com/tags/排序/"}]},{"title":"算法:简单排序2-选择排序","date":"2018-03-18T02:31:00.000Z","path":"2018/03/18/算法-选择排序/","text":"简单排序2-选择排序 思路 1.每一次循环时把第1个位置为最小的，依次变大 2.循环如果比最小的小那就标记为最小，如果有更小的就标记更小的为最小 3.循环一次比较后把第1个位置和最小的那个交换位置 SortUtils.java 主要完成换位和打印任务，在之后的简单排序中都会用此工具类 12345678910111213141516171819202122public class SortUtils &#123; /** * @param array=数组 * @param index=当前位置 * @param next=下一个位置 */ public static void swap(int[] array,int index,int next)&#123; int tmp=array[index]; array[index]=array[next]; array[next]=tmp; &#125; /** * @param array=要打印的数组 */ public static void display(int[] array)&#123; for(int i=0;i&lt;array.length;i++)&#123; System.out.print(\" \"+array[i]); &#125; &#125;&#125; Selection.java 具体实现 12345678910111213141516171819public class Selection &#123; public static int array[] = &#123; 5, 6, 3 &#125;; public static void main(String[] args) &#123; int min; for (int out = 0; out &lt; array.length - 1; out++) &#123; //1 min = out; //2 for (int in = out + 1; in &lt; array.length; in++) &#123;//3 if (array[in] &lt; array[min]) &#123; min = in; //4 &#125; &#125; SortUtils.swap(array, out, min); //5 &#125; SortUtils.display(array); &#125;&#125; 输出：3 5 6 说明 1.循环次数为小于array.length-1次，才能在最后一次循环时和in的最后一个元素比较大小 2.每次循环的第一位置为最小的，结束循环后小的要到这个位置 3.被比较的数是out+1开始一直到数组最后一个位置 4.被比较的小的话，min位置就标记为当前循环的位置 5.整个循环后交换开始循环的位置和被标记最小的位置 注:该内容为Java数据结构和算法读后学习感悟 其他相关文章递归-归并排序 高级排序2-快速排序 划分排序 高级排序1-希尔排序 简单排序3-插入排序 简单排序1-冒泡排序","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://www.caoyongjun.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://www.caoyongjun.com/tags/排序/"}]},{"title":"算法:简单排序1-冒泡排序","date":"2018-03-17T10:03:00.000Z","path":"2018/03/17/算法-冒泡排序/","text":"简单排序1-冒泡排序 思路 1.每次从左开始两个紧邻元素比较大小，如果大就交换位置到右边。 2.得到大数并且交换到右边位置后，它继续和它的右边一个数比较大小重复1步骤，这样重复下来第一轮最后一个位置就是最大数。 3.下次排序时重复1,2步骤一直到上一次排好顺序的前一个位置上。 SortUtils.java 主要完成换位和打印任务，在之后的简单排序中都会用此工具类 12345678910111213141516171819202122public class SortUtils &#123; /** * @param array=数组 * @param index=当前位置 * @param next=下一个位置 */ public static void swap(int[] array,int index,int next)&#123; int tmp=array[index]; array[index]=array[next]; array[next]=tmp; &#125; /** * @param array=要打印的数组 */ public static void display(int[] array)&#123; for(int i=0;i&lt;array.length;i++)&#123; System.out.print(\" \"+array[i]); &#125; &#125;&#125; Bubble.java 具体实现 1234567891011121314151617181920public class Bubble &#123; public static int array[]=&#123;5,6,3&#125;; public static void main(String[] args) &#123; for (int out = array.length-1; out &gt; 0; out-- ) &#123;//1 for (int in = 0; in &lt; out; in++ ) &#123;//2 if ( array[in] &gt; array[in+1] ) &#123;//3 SortUtils.swap(array, in, in+1);//交换位置 &#125; &#125; &#125; SortUtils.display(array);//打印排序好的数据 &#125;&#125; 输出：3 5 6 说明 1.主要负责两个功能。1:外层计数器总共要进行几次的交换位置，2:内层循环时比大小的停止位置 2.每次从0位置开始和下一个位置比对大小，一直遇到out的停止排序的位置为止 3.如果这里是&gt; 那么最终结果是3 5 6，如果这里是&lt; 最终结果是6 5 3 简单排序1-冒泡排序优化版在相对已经有序的数组中冒泡排序缺点是最后几个位置已经是固定的顺序时每次还会去消耗时间去比较大小。比如：5,6,3,1,2,0,7,8,9本身已经没有比较再去比较7,8,9但是还会在前三轮比较 优化思路 1.增加一个标识符来判断内循环时有无交换数据，如果内循环一次交换都没有发生就说明已经是有序数据，不用在消耗时间去做不必要地比较。 2.记录上一次交换索引的位置(lastExchangeIndex)，每次数据比较只交换到lastExchangeIndex索引上，不用再去比较右边已经有序的数据。 BubbleOptimize.java 具体实现 1234567891011121314151617181920212223242526272829public class BubbleOptimize &#123; public static int array[]=&#123;5,6,3,1,2,0,7,8,9&#125;; public static void main(String[] args) &#123; int lastExchangeIndex=array.length-1; //1 int sortLength=array.length-1; for (int out = 0; out &lt; array.length; out++) &#123; boolean isSorted=true; //2 for (int in = 0; in &lt; sortLength; in++) &#123; //3 if ( array[in] &gt; array[in+1] ) &#123; SortUtils.swap(array, in, in+1);//交换位置 isSorted=false; //4 lastExchangeIndex=in; //5 &#125; &#125; sortLength=lastExchangeIndex; //6 if(isSorted)&#123; //7 break; &#125; &#125; SortUtils.display(array);//打印排序好的数据 &#125;&#125; 输出：0 1 2 3 5 6 7 8 9 说明 1.初始化上一次交换索引位置，初始化比较结束位置 2.每次内循环开始前初始化交换标识符，假设每一次都没有交换 3.内循环开始，结束条件为上一次交换索引的位置 4.只要有交换就把标识符变为false，让它继续交换大小 5.每次交换位置后记录上一次交换索引的位置 6.把上一次交换位置给到下一次内循环的长度 7.如果内循环没有比较过就跳出整个比较 注:该内容为Java数据结构和算法读后学习感悟 其他相关文章递归-归并排序 高级排序2-快速排序 划分排序 高级排序1-希尔排序 简单排序3-插入排序 简单排序2-选择排序","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://www.caoyongjun.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://www.caoyongjun.com/tags/排序/"}]},{"title":"java:垃圾回收机制2-判断哪些类可回收","date":"2018-03-14T11:50:00.000Z","path":"2018/03/14/java-垃圾回收机制2-判断哪些类可回收/","text":"分代收集算法 当前商业虚拟机的垃圾收集都采用“分代收集”按对象存活周期将内存划分为新生代和老年代。根据各年代的特点采用最适当的收集算法。 1.新生代每次垃圾收集时都会有大批对象死去，只有少量存活，所以使用“复制算法”，只需要付出少量存活对象的复制成本就可以完成收集。 1.1.复制算法 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将存活的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉。 优点-每次都是对整个半区进行内存回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点-内存缩小为了原来的一半。 1.2.新生代复制算法 由于在新生代的对象98%都是朝生夕死不需要按照1:1的比例划分内存空间,而是将内存分为一块大的Eden空间和两较小的Survivor空间(默认8:1大小) 每次使用都会占据Eden和其中一个Survivor 垃圾回收时会把Eden和Survivor生存的对象复制到另外一个Survivor，然后清空Eden和来源Survivor 如果目标Survivor内存空间不足时，需要依赖老年代空间进行分配担保 2.老年代因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 2.1.标记-清理 首先标记出所有需要回收的对象，然后统一回收被标记的对象。 缺点1-效率低，标记和清除两个过程的效率都不高。 缺点2-空间碎片多，清除后会产生大量不连续的内存碎片，碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 2.2.标记-整理 标记阶段和“标记-清理”算法一样，整理时把存活对象都向一端移动，然后直接清理端边界以外的内存 以上内容为《深入理解Java虚拟机》读后笔记，图是自己理解后用Excel画出的","comments":true,"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.caoyongjun.com/tags/jvm/"}]},{"title":"java:垃圾回收机制","date":"2018-03-14T10:11:00.000Z","path":"2018/03/14/java-垃圾回收机制/","text":"分代收集算法 当前商业虚拟机的垃圾收集都采用“分代收集”按对象存活周期将内存划分为新生代和老年代。根据各年代的特点采用最适当的收集算法。 1.新生代每次垃圾收集时都会有大批对象死去，只有少量存活，所以使用“复制算法”，只需要付出少量存活对象的复制成本就可以完成收集。 1.1.复制算法 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将存活的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉。 优点-每次都是对整个半区进行内存回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点-内存缩小为了原来的一半。 1.2.新生代复制算法 由于在新生代的对象98%都是朝生夕死不需要按照1:1的比例划分内存空间,而是将内存分为一块大的Eden空间和两较小的Survivor空间(默认8:1大小) 每次使用都会占据Eden和其中一个Survivor 垃圾回收时会把Eden和Survivor生存的对象复制到另外一个Survivor，然后清空Eden和来源Survivor 如果目标Survivor内存空间不足时，需要依赖老年代空间进行分配担保 2.老年代因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 2.1.标记-清理 首先标记出所有需要回收的对象，然后统一回收被标记的对象。 缺点1-效率低，标记和清除两个过程的效率都不高。 缺点2-空间碎片多，清除后会产生大量不连续的内存碎片，碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 2.2.标记-整理 标记阶段和“标记-清理”算法一样，整理时把存活对象都向一端移动，然后直接清理端边界以外的内存 以上内容为《深入理解Java虚拟机》读后笔记，图是自己理解后用Excel画出的","comments":true,"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.caoyongjun.com/tags/jvm/"}]},{"title":"log-springBoot中logback配置不同类日志输出到不同日志文件","date":"2018-02-24T09:15:04.000Z","path":"2018/02/24/log-logback配置/","text":"1.application.properties文件中引用到lockback.xml文件 1logging.file=classpath:logback.xml 2.lockback.xml中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--scan:true时配置文件如果发生改变，将会被重新加载。(默认true)scanPeriod:scan=true时生效，监测配置文件是否有修改的时间间隔，如果没有时间单位，默认单位毫秒，默认事件间隔1分钟debug:true时打印出logback内部日志信息，实时查看logback运行状态--&gt;&lt;configuration scan=\"false\" scanPeriod=\"60 seconds\" debug=\"false\"&gt; &lt;!--定义控制台输出--&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;Encoding&gt;UTF-8&lt;/Encoding&gt; &lt;!-- %thread = 线程名称 %-5level = 级别从左显示15个字符宽 %logger&#123;0&#125; = logger类的名字，如果不写则会打印该类的全路径列如%logger 会输出com.xxx.Interview.jvm.model.TicketRunnable 如果%logger&#123;0&#125;会输出TicketRunnable 长度大于0小于类全路径就会缩短全路径名例如c.xxx.Interview.jvm.model.TicketRunnable %msg = 日志内容 %n = 换行符 --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name=\"rollingFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;Encoding&gt;UTF-8&lt;/Encoding&gt; &lt;!-- 发生滚动时，决定RollingFileAppender的行为 它根据时间来制定滚动策略 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;/home/caoyongjun/app/logs/msapi.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;!-- 保存日志最长时间 --&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--异步的redis队列执行的数据--&gt; &lt;appender name=\"redisQueueFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;/home/caoyongjun/app/logs/msapi-redis-queue.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--定时任务的数据--&gt; &lt;appender name=\"scheduleFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;/home/caoyongjun/app/logs/msapi-schedule.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"errorFile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;/home/caoyongjun/app/logs/msapi-error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;appender-ref ref=\"rollingFile\" /&gt; &lt;/root&gt; &lt;!--隐藏掉包名--&gt; &lt;logger name=\"com.111\" level=\"debug\"/&gt; &lt;!--additivity=false时不会追加到root定义的文件里面，只会追加到当前errorFile里面，如果additivity=true root里面没有定义ref也不生效--&gt; &lt;logger name=\"com.111\" level=\"error\" additivity=\"false\"&gt; &lt;appender-ref ref=\"errorFile\" /&gt; &lt;/logger&gt; &lt;!--因为和上面的level=debug冲突所以这里改为了trace redis异步 subservice和publishservice要改一下--&gt; &lt;logger name=\"com.111.queue\" level=\"trace\" additivity=\"false\"&gt; &lt;appender-ref ref=\"redisQueueFile\" /&gt; &lt;/logger&gt; &lt;logger name=\"com.111.schedule\" level=\"info\" additivity=\"false\"&gt; &lt;appender-ref ref=\"scheduleFile\" /&gt; &lt;/logger&gt; &lt;jmxConfigurator/&gt;&lt;/configuration&gt;","comments":true,"tags":[{"name":"log","slug":"log","permalink":"http://www.caoyongjun.com/tags/log/"},{"name":"springBoot","slug":"springBoot","permalink":"http://www.caoyongjun.com/tags/springBoot/"}]},{"title":"Spring:spring事务管理","date":"2018-02-23T08:21:22.000Z","path":"2018/02/23/spring-事务管理/","text":"总结项目中用到的@Transactional注解由于是aop切面实现的同一级别下调用有注解的方法时不会触发事务的回滚所以一定要从a类调用b类的某个有注解的方法才能生效 1.属性说明 属性 是否必需 默认 描述 value 否 空 限定描述符，指定使用的事务管理器 transactionManager 否 空 限定描述符，指定使用的事务管理器 Propagation 否 Propagation.REQUIRED 事务传播行为 Isolation 否 Isolation.DEFAULT 事务隔离级别 timeout 否 TransactionDefinition.TIMEOUT_DEFAULT(-1) 事务超时的值默认不超时 readOnly 否 false 设置事务是否为只读 rollbackFor 否 空 触发回滚的异常；多个异常用逗号rollbackFor=Throwable.class rollbackForClassName 否 空 触发回滚的异常；多个异常用逗号分割，可简化类名称如rollbackForClassName={“Exception”,”Throwable”} noRollbackFor 否 空 不触发回滚的异常，多个异常用逗号分割 noRollbackForClassName 否 空 不触发回滚的异常，多个异常用逗号分割，可简化类名称如noRollbackForClassName={“Exception”,”Throwable”} 2.7种传播行为 传播行为 意义 PROPAGATION_MANDATORY 表示该方法必须运行在一个事务中。如果当前事务不存在，将抛出一个异常 PROPAGATION_NESTED 表示如果当前已存在一个事务，则该方法应当运行在一个嵌套的事务中。被嵌套的事务可以从当前事务中单独的提交或回滚。如果当前事务不存在，那么它看起来就和PROPAGATION_REQUIRED没两样。请注意各厂商对于这种传播行为的支持是参差不齐的。请参考资源管理器的文档，确定它们是否支持嵌套事务 PROPAGATION_NEVER 表示当前方法不应该运行在一个事务上下文中。如果当前存在一个事务，则会抛出一个异常 PROPAGATION_NOT_SUPPORTED 表示该方法不应在事务中运行。如果一个现有的事务正在进行中，它将在该方法的运行期间被挂起。 PROPAGATION_REQUIRED 表示当前方法必须运行在一个事务中。如果一个现有的事务正在进行中，该方法将运行在这个事务中。否则的话，就要开始一个新的事务 PROPAGATION_REQUIRES_NEW 表示当前方法必须运行在它自己的事务里。它将启动一个新的事务。如果一个现有事务在运行的话，将在这个方法运行期间被挂起。 PROPAGATION_SUPPORTS 表示当前方法不需要事务处理环境，但如果有一个事务已经在运行的话，这个方法也可以在这个事务里运行 3.5种隔离级别多个事务并发运行，经常会操作同一个数据来完成任务。但是并发会导致下列问题： 脏读（Dirty read）——脏读发生在一个事务读取了被另一个改写但还未提交的数据时。如果这些改变在稍后被回滚，那么第一个事务读取的数据就是无效的。 不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行的查询两次或两次以上，但每一次查询结果都不同时。这通常是由于另外一个并发事务在两次查询之间更新了数据。 幻读（Phantom read）——幻读和不可重复读相似。当一个事务读取几行记录后，另一个并发事务插入一些记录，幻读就发生了。在后来的查询中，第一个事务就会发现一些原来没有的额外记录。 隔离级别 含义 ISOLATION_DEFAULT 使用数据库默认的隔离级别 ISOLATION_READ_UNCOMMITTED 读未提交 允许你读取还未提交的改变了的数据。可能导致脏读、幻读或不可重复读 ISOLATION_READ_COMMITTED 读提交 允许在并发事务已经提交后读取。可防止脏读、幻读或不可重复读 ISOLATION_REPEATABLE_READ 重复读 对相同字段的多次读取的结果是一致的，除非数据被事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生 ISOLATION_SERIALIZABLE 序列化 完全服从ACID（原子性，一致性，隔离性，持久性）的隔离级别，确保不发生脏读、不可重复读和幻读。这在所有隔离级别中也是最慢的，因为它是典型的通过完全锁定在事务中涉及的数据表来完成的 ISOLATION_READ_UNCOMMITTED是最高效的隔离级别，但是事务的隔离程度也是最低的，事务对脏读、不可重复读和幻读是开放的。在另一个极端，ISOLATION_SERIALIZABLE防止任何形式的隔离问题，但效率是最低的。要知道并不是所有的事务管理器都支持表三所列的隔离级别，请参考你的事务管理器文档，来确定有哪些可使用的隔离级别。 4.只读如果事务只针对数据库执行读操作，数据库就会针对只读特性做优化操作。因为只读的优化措施是在事务启动时由后端数据库实施的，所以，只有将那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义（PROPAGATON_REQUIRED,PROPAGATION_REQUIRED_NEW和PROPAGATION_NEXTED）。 5.事务超时事务可能对数据库锁定，长时间运行的事务会不必要的占用数据库资源。 6.回滚事务rollbackFor指定了某个异常类后，方法里面抛出此类或者子类都会抛出异常。但如果默认不写就不会抛出受检查的Exception,只能回滚RuntimeException","comments":true,"tags":[{"name":"spring","slug":"spring","permalink":"http://www.caoyongjun.com/tags/spring/"}]},{"title":"java:cdn图片导出成word内容","date":"2018-02-22T09:11:22.000Z","path":"2018/02/22/java-cdn图片导出成word内容/","text":"项目需求把聊天记录中的文字和存放在cdn中的图片导出成word内容，使用到了mht(今日主要的坑在于cdn外链图片如何放入到word中)百度中的mht的定义1MHTML文件又称为聚合HTML文档、Web档案或单一文件网页。单个文件网页可将网站的所有元素（包括文本和图形）都保存到单个文件中。这种封装使您可将整个网站发布为单个内嵌MIME （MIME：通过 Internet 连接传递多媒体资源的一列标准。MIME类型通知程序对象所包含的内容（如图形、声音或视频)的聚合HTML文档(MHTML)文件，或将整个网站作为一个电子邮件或附件发送。Internet Explorer 4.0及更高版本支持此格式。 由于每个聊天记录的图片都是放入到了oss中所以为了要放入word里面避免无外网情况下查看到图片所以每次在导出时先去判断是否已经下载过该图如果下载了那就只取，并把图片使用base64加密到mht中，具体的实现看以下部分 用到的一些知识补充1.Content-Location首部字段表示的是报文主体返回资源对应的URI(统一资源标识符Uniform Resource Identifier)当返回的页面内容与实际请求的对象不同时，首部字段Content-Location内会写明URI代码中file:///C:/9FD15EF4/file8676.htm 2.Content-Transfer-Encoding规定了传输报文主体时采用的编码方式代码中Content-Transfer-Encoding: quoted-printable 3.Content-Typemultipart/related=内嵌资源boundary=使用字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入“–”标记（例如：——=_NextPart_01CFAA79.4B969C00），而在多部分对象集合对应的字符串的最后插入“–”（例如：——=_NextPart_01CFAA79.4B969C00–）作为结束 4.MIME（Multipurpose Internet Mail Extensions多用途因特网邮件扩展）机制mime允许处理文本，图片，视频等不同类型的数据。而在mime扩展中会使用一种称为多部分对象集合的方法，来容纳多分不同类型的数据。 实际代码1.pom.xml 为了导出模板使用freemarker12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt; 2.mhtword.ftl 模板中的内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202MIME-Version: 1.0Content-Type: multipart/related; boundary=\"----=_NextPart_01CFAA79.4B969C00\"此文档为“单个文件网页”，也称为“Web 档案”文件。如果您看到此消息，但是您的浏览器或编辑器不支持“Web 档案”文件。请下载支持“Web 档案”的浏览器，如 Microsoft Internet Explorer。------=_NextPart_01CFAA79.4B969C00Content-Location: file:///C:/9FD15EF4/file8676.htmContent-Transfer-Encoding: quoted-printableContent-Type: text/html; charset=\"utf-8\"&lt;html xmlns:v=3D\"urn:schemas-microsoft-com:vml\"xmlns:o=3D\"urn:schemas-microsoft-com:office:office\"xmlns:w=3D\"urn:schemas-microsoft-com:office:word\"xmlns=3D\"http://www.w3.org/TR/REC-html40\"&gt;&lt;head&gt;&lt;meta http-equiv=3DContent-Type content=3D\"text/html; charset=3Dutf-8\"&gt;&lt;meta name=3DProgId content=3DWord.Document&gt;&lt;meta name=3DGenerator content=3D\"Microsoft Word 11\"&gt;&lt;meta name=3DOriginator content=3D\"Microsoft Word 11\"&gt;&lt;link rel=3DFile-List href=3D\"file8676.files/filelist.xml\"&gt;&lt;link rel=3DEdit-Time-Data href=3D\"file8676.files/editdata.mso\"&gt;&lt;!--[if !mso]&gt;&lt;style&gt;v\\:* &#123;behavior:url(#default#VML);&#125;o\\:* &#123;behavior:url(#default#VML);&#125;w\\:* &#123;behavior:url(#default#VML);&#125;.shape &#123;behavior:url(#default#VML);&#125;&lt;/style&gt;&lt;![endif]--&gt;&lt;title&gt;$&#123;title&#125;&lt;/title&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt; &lt;o:DocumentProperties&gt; &lt;o:Author&gt;User&lt;/o:Author&gt; &lt;o:LastAuthor&gt;User&lt;/o:LastAuthor&gt; &lt;o:Revision&gt;3&lt;/o:Revision&gt; &lt;o:TotalTime&gt;1&lt;/o:TotalTime&gt; &lt;o:Created&gt;2014-07-28T07:16:00Z&lt;/o:Created&gt; &lt;o:LastSaved&gt;2014-07-28T07:33:00Z&lt;/o:LastSaved&gt; &lt;o:Pages&gt;1&lt;/o:Pages&gt; &lt;o:Words&gt;11&lt;/o:Words&gt; &lt;o:Characters&gt;63&lt;/o:Characters&gt; &lt;o:Company&gt;&amp;#24494;&amp;#36719;&amp;#20013;&amp;#22269;&lt;/o:Company&gt; &lt;o:Lines&gt;1&lt;/o:Lines&gt; &lt;o:Paragraphs&gt;1&lt;/o:Paragraphs&gt; &lt;o:CharactersWithSpaces&gt;73&lt;/o:CharactersWithSpaces&gt; &lt;o:Version&gt;11.9999&lt;/o:Version&gt; &lt;/o:DocumentProperties&gt;&lt;/xml&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt; &lt;w:WordDocument&gt; &lt;w:SpellingState&gt;Clean&lt;/w:SpellingState&gt; &lt;w:GrammarState&gt;Clean&lt;/w:GrammarState&gt; &lt;w:PunctuationKerning/&gt; &lt;w:DrawingGridVerticalSpacing&gt;7.8 &amp;#30917;&lt;/w:DrawingGridVerticalSpacing&gt; &lt;w:DisplayHorizontalDrawingGridEvery&gt;0&lt;/w:DisplayHorizontalDrawingGridEve=ry&gt; &lt;w:DisplayVerticalDrawingGridEvery&gt;2&lt;/w:DisplayVerticalDrawingGridEvery&gt; &lt;w:ValidateAgainstSchemas/&gt; &lt;w:SaveIfXMLInvalid&gt;false&lt;/w:SaveIfXMLInvalid&gt; &lt;w:IgnoreMixedContent&gt;false&lt;/w:IgnoreMixedContent&gt; &lt;w:AlwaysShowPlaceholderText&gt;false&lt;/w:AlwaysShowPlaceholderText&gt; &lt;w:Compatibility&gt; &lt;w:SpaceForUL/&gt; &lt;w:BalanceSingleByteDoubleByteWidth/&gt; &lt;w:DoNotLeaveBackslashAlone/&gt; &lt;w:ULTrailSpace/&gt; &lt;w:DoNotExpandShiftReturn/&gt; &lt;w:AdjustLineHeightInTable/&gt; &lt;w:BreakWrappedTables/&gt; &lt;w:SnapToGridInCell/&gt; &lt;w:WrapTextWithPunct/&gt; &lt;w:UseAsianBreakRules/&gt; &lt;w:DontGrowAutofit/&gt; &lt;w:UseFELayout/&gt; &lt;/w:Compatibility&gt; &lt;w:BrowserLevel&gt;MicrosoftInternetExplorer4&lt;/w:BrowserLevel&gt; &lt;/w:WordDocument&gt;&lt;/xml&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt; &lt;w:LatentStyles DefLockedState=3D\"false\" LatentStyleCount=3D\"156\"&gt; &lt;/w:LatentStyles&gt;&lt;/xml&gt;&lt;![endif]--&gt;&lt;style&gt;&lt;!-- /* Font Definitions */ @font-face &#123;font-family:SimSun; panose-1:2 1 6 0 3 1 1 1 1 1; mso-font-alt:SimSun; mso-font-charset:134; mso-generic-font-family:auto; mso-font-pitch:variable; mso-font-signature:3 135135232 16 0 262145 0;&#125;@font-face &#123;font-family:SimSun; panose-1:2 1 6 0 3 1 1 1 1 1; mso-font-charset:134; mso-generic-font-family:auto; mso-font-pitch:variable; mso-font-signature:3 135135232 16 0 262145 0;&#125; /* Style Definitions */ p.MsoNormal, li.MsoNormal, div.MsoNormal &#123;mso-style-parent:\"\"; margin:0cm; margin-bottom:.0001pt; text-align:justify; text-justify:inter-ideograph; mso-pagination:none; font-size:10.5pt; mso-bidi-font-size:10.0pt; font-family:\"Times New Roman\"; mso-fareast-font-family:SimSun; mso-font-kerning:1.0pt;&#125;span.GramE &#123;mso-style-name:\"\"; mso-gram-e:yes;&#125; /* Page Definitions */ @page &#123;mso-page-border-surround-header:no; mso-page-border-surround-footer:no;&#125;@page Section1 &#123;size:595.3pt 841.9pt; margin:72.0pt 90.0pt 72.0pt 90.0pt; mso-header-margin:42.55pt; mso-footer-margin:49.6pt; mso-paper-source:0; layout-grid:15.6pt;&#125;div.Section1 &#123;page:Section1;&#125;--&gt;&lt;/style&gt;&lt;!--[if gte mso 10]&gt;&lt;style&gt; /* Style Definitions */ table.MsoNormalTable &#123;mso-style-name:\\666E\\901A\\8868\\683C; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-parent:\"\"; mso-padding-alt:0cm 5.4pt 0cm 5.4pt; mso-para-margin:0cm; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:\"Times New Roman\"; mso-fareast-font-family:\"Times New Roman\"; mso-ansi-language:#0400; mso-fareast-language:#0400; mso-bidi-language:#0400;&#125;&lt;/style&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt; &lt;o:shapedefaults v:ext=3D\"edit\" spidmax=3D\"2050\"/&gt;&lt;/xml&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt; &lt;o:shapelayout v:ext=3D\"edit\"&gt; &lt;o:idmap v:ext=3D\"edit\" data=3D\"1\"/&gt; &lt;/o:shapelayout&gt;&lt;/xml&gt;&lt;![endif]--&gt;&lt;/head&gt;&lt;body lang=3DZH-CN style=3D'tab-interval:21.0pt;text-justify-trim:punctuati=on'&gt;&lt;div class=3DSection1 style=3D'layout-grid:15.6pt'&gt;&lt;p class=3DMsoNormal align=3Dleft style=3D'text-align:left;mso-outline-level:1'&gt; &lt;span style=3D'font-size:12.0pt;font-family:宋体;mso-ascii-font-family:\"Times New Roman\";mso-hansi-font-family:\"Times New Roman\"'&gt; $&#123;content&#125; &lt;/span&gt; &lt;span lang=EN-US style=3D'font-size:12.0pt;font-family:宋体'&gt; &lt;o:p&gt;&lt;/o:p&gt; &lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;#list imageList as imageMap&gt;------=_NextPart_01CFAA79.4B969C00Content-Location: file:///C:/9FD15EF4/file8676.files/$&#123;imageMap[\"imageName\"]&#125;Content-Transfer-Encoding: base64Content-Type: image/$&#123;imageMap[\"imageType\"]&#125;$&#123;imageMap[\"imageBase\"]&#125;&lt;/#list&gt;------=_NextPart_01CFAA79.4B969C00Content-Location: file:///C:/9FD15EF4/file8676.files/filelist.xmlContent-Transfer-Encoding: quoted-printableContent-Type: text/xml; charset=\"utf-8\"&lt;xml xmlns:o=3D\"urn:schemas-microsoft-com:office:office\"&gt;&lt;o:MainFile HRef=3D\"../file8676.htm\"/&gt;&lt;#list imageList as imageMap&gt;&lt;o:File HRef=3D\"$&#123;imageMap[\"imageName\"]&#125;\"/&gt;&lt;/#list&gt; &lt;o:File HRef=3D\"filelist.xml\"/&gt;&lt;/xml&gt;------=_NextPart_01CFAA79.4B969C00-- 3.具体实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package com.shanyuan.political.party.platform.controller.admin.meeting;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.io.UnsupportedEncodingException;import java.io.Writer;import java.net.URL;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.imageio.ImageIO;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.io.FileUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import com.shanyuan.political.party.platform.common.util.Md5Util;import com.shanyuan.political.party.platform.facade.meeting.MeetingFacade;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateException;import sun.misc.BASE64Encoder;@SuppressWarnings(\"restriction\")@Controller@CrossOrigin@RequestMapping(value=\"/admin-meeting\")public class AdminMeetingController &#123; @Autowired private MeetingFacade meetingFacade; public void createDoc(Map&lt;String,Object&gt; dataMap,Writer out) &#123; //设置模本装置方法和路径,FreeMarker支持多种模板装载方法。可以重servlet，classpath，数据库装载， @SuppressWarnings(\"deprecation\") Configuration configuration = new Configuration(); configuration.setDefaultEncoding(\"utf-8\"); configuration.setClassForTemplateLoading(this.getClass(), \"/\"); Template t=null; try &#123; //放在resources/template 目录下面 t = configuration.getTemplate(\"template/mhtword.ftl\", \"UTF-8\"); t.process(dataMap, out); &#125; catch (TemplateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /* * &lt;img/&gt; * &lt;img/&gt; ==&gt; * &lt;v:shape style=3D'width:352.5pt;height:318.75pt'&gt; &lt;v:imagedata src=3D\"file8676.files/image002.jpg\" o:title=3D\"logo\"/&gt; &lt;/v:shape&gt; */ public Map&lt;String,Object&gt; exImageToD(HttpServletRequest request,String content) throws FileNotFoundException, IOException &#123; Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;(); List&lt;String&gt; imgList=new ArrayList&lt;&gt;(); String regex = \"&lt;img[^&gt;]+src\\\\s*=\\\\s*['\\\"]([^'\\\"]+)['\\\"][^&gt;]*&gt;\"; content = content.replaceAll(\"(style=)\",\"$13D\"); Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(content); String src = \"\"; String srcPath=request.getSession().getServletContext().getRealPath(\"/\"); while (matcher.find())&#123; try&#123; src = matcher.group(1); if(src.indexOf(\"http\")==0)&#123; //新的图片名称 他的路径是 https://xxxxx.jpg ==&gt; md5()+\".png\" String newSrc=Md5Util.getMD5Lower(src)+\".png\"; //存放到某个位置 String srcRealPathFile = srcPath + newSrc; File newFile=new File(srcRealPathFile); //不存在时才去网络下载到指定文件夹下 if(!newFile.exists())&#123; FileUtils.copyURLToFile(new URL(src), newFile); &#125; //把图片内容修改为mhtm可读的标签形式 content = content.replaceFirst(regex, appendShap(newSrc)); imgList.add(newSrc);//记录图片路径 &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; map.put(\"content\", content); map.put(\"imgList\", imgList); return map; &#125; //获得图片的base64码 public String getImageBase(HttpServletRequest request,String src) &#123; File file = new File(request.getSession().getServletContext().getRealPath(\"/\")+src.replace(request.getContextPath(), \"\")); if(!file.exists()) &#123; return \"\"; &#125; InputStream in = null; byte[] data = null; try &#123; in = new FileInputStream(file); &#125; catch (FileNotFoundException e1) &#123; e1.printStackTrace(); &#125; try &#123; data = new byte[in.available()]; in.read(data); in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new BASE64Encoder().encode(data); &#125; private String appendShap(String str)&#123; String shape = \"&lt;v:shape type=3D\\\"#_x0000_t75\\\" style=3D'width:\" + 100 + \";height:\" + 100 + \"'&gt;\" + \"&lt;v:imagedata src=3D\\\"file8676.files/\" + str + \" \\\"o:title=3D\" + str + \"\\\"/&gt;\" + \"&lt;/v:shape&gt;\"; return shape; &#125; //这里面要注意的一个问题是type=3D\\\"#_x0000_t75\\ 这是一定要加上的不然在2003中能看到图片，到了2007中就看不到了action @GetMapping(\"/download-meeting-summary\") public void exportBlog(@RequestParam(value=\"meetingid\",required=true) Integer meetingId,HttpServletResponse response, HttpServletRequest request) throws UnsupportedEncodingException &#123; response.addHeader(\"Content-Disposition\",\"attachment;filename=\"+ new String(\"组织生活\".getBytes(\"GBK\"), \"iso-8859-1\") + \".doc\"); response.setContentType(\"application/x-download\");// 设置为下载application/x-download response.setCharacterEncoding(\"utf-8\"); PrintWriter output = null; try &#123; Map&lt;String,Object&gt; dataMap = new HashMap&lt;String,Object&gt;();//填充的数据 output = response.getWriter(); String content=meetingFacade.getSummary(meetingId); Map&lt;String,Object&gt; setMap=exImageToD(request,content); dataMap.put(\"content\", setMap.get(\"content\")); dataMap.put(\"title\", \"组织生活\"); List&lt;String&gt; srcs = (List&lt;String&gt;) setMap.get(\"imgList\"); Map&lt;String, String&gt; imageMap = null; List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;Map&lt;String,String&gt;&gt;(); String[] sp = null; for(String src : srcs)&#123; sp = src.split(\"/\"); imageMap = new HashMap&lt;String, String&gt;(); imageMap.put(\"imageName\", sp[sp.length-1]); imageMap.put(\"imageType\", sp[sp.length-1].split(\"\\\\.\")[1]); imageMap.put(\"imageBase\", getImageBase(request,src)); list.add(imageMap); &#125; dataMap.put(\"imageList\", list); createDoc(dataMap,output); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; output.flush(); output.close(); &#125; &#125;&#125; 输出word内容","comments":true,"tags":[{"name":"java","slug":"java","permalink":"http://www.caoyongjun.com/tags/java/"}]},{"title":"sql集合思想的一个例子","date":"2018-02-03T05:20:00.000Z","path":"2018/02/03/sql集合思想的一个例子/","text":"一次sql解决以下结果集 问：有一个员工表emp 10000+数据emp_no=员工编号,dept_no=部门编号,job=null:其他,CLERK:员工,MANAGE:经理,sal=工资 有一个部门表dept 50个条部门数据dept_no=部门编号,dept_name=部门名 解决sql1.emp表通过group by dept缩小范围并且按照各自的职位计算出各职位对应的工资和部门总工资 12345678SELECT dept_no, SUM(IF(job='MANAGE',sal,0))AS manage, SUM(IF(job='CLERK',sal,0))AS cleark, SUM(IF(job IS NULL,sal,0))AS etc, SUM(sal)AS dept_salFROM empGROUP BY dept_no 2.缩小范围的emp和dept一一对应50找50 123456789101112SELECT b.dept_name,a.dept_no,a.manage,a.cleark,a.etc,a.dept_salFROM ( SELECT dept_no, SUM(IF(job='MANAGE',sal,0))AS manage, SUM(IF(job='CLERK',sal,0))AS cleark, SUM(IF(job IS NULL,sal,0))AS etc, SUM(sal)AS dept_sal FROM emp GROUP BY dept_no) AS a,dept bWHERE a.dept_no=b.dept_no 3.此时已经有了50条各部门数据但是差一条汇总数据,要用到笛卡尔积方法来实现汇总。 3.1.建立两张虚表50*2=100 3.2.按部门分组1为有部门,2为没部门 3.3.然后select的部分区分一下 123456789101112131415161718192021222324252627SELECT IFNULL(IF(d.NO='1',c.dept_name,NULL),'汇总') AS dname, SUM(c.manage)AS manage, SUM(c.cleark)AS cleark, SUM(c.etc)AS etc, SUM(c.dept_sal)AS dept_salFROM ( SELECT b.dept_name,a.dept_no,a.manage,a.cleark,a.etc,a.dept_sal FROM ( SELECT dept_no, SUM(IF(job='MANAGE',sal,0))AS manage, SUM(IF(job='CLERK',sal,0))AS cleark, SUM(IF(job IS NULL,sal,0))AS etc, SUM(sal)AS dept_sal FROM emp GROUP BY dept_no ) AS a,dept b WHERE a.dept_no=b.dept_no AND b.dept_no&gt;0) c,(SELECT '1' AS NO FROM DUALUNION ALLSELECT '2' FROM DUAL) AS dGROUP BY IF(d.NO='1',c.dept_name,NULL)ORDER BY d.NO,c.dept_no 3.4.执行计划 3.5.执行计划结果说明参考下面这个人的博客explain说明","comments":true,"tags":[{"name":"sql","slug":"sql","permalink":"http://www.caoyongjun.com/tags/sql/"}]},{"title":"java:使用BigDecimal除法时需要注意的点","date":"2017-12-20T08:59:00.000Z","path":"2017/12/20/java-bigDecimal-divide-round/","text":"百度中BigDecimal的定义Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。 在工作中金额计算时会用到Bigdecimal。但是遇到除法时如果不定义精确到小数点第几位的话容易出现以下结果123.4577799999999996316546457819640636444091796875 为了获取业务中需要的精确保留2位小数点的场景通过代码来看一下api中提供的Rounding参数 1234567891011121314151617181920import java.math.BigDecimal;public class Test &#123; public static void main(String[] args) &#123; BigDecimal a=new BigDecimal(123.45778);//第三位&gt;5 BigDecimal a2=new BigDecimal(123.45378);//第三位&lt;5 BigDecimal b=new BigDecimal(1); System.out.println(a.divide(b,2,BigDecimal.ROUND_CEILING)+\" \"+a2.divide(b,2,BigDecimal.ROUND_CEILING)+\" ceiling:小数点后第二位数+1\"); System.out.println(a.divide(b,2,BigDecimal.ROUND_FLOOR)+\" \"+a2.divide(b,2,BigDecimal.ROUND_FLOOR)+\" floor:小数点后第二位数不变\"); System.out.println(a.divide(b,2,BigDecimal.ROUND_DOWN)+\" \"+a2.divide(b,2,BigDecimal.ROUND_DOWN)+\" down:小数点后第二位数不变\"); System.out.println(a.divide(b,2,BigDecimal.ROUND_UP)+\" \"+a2.divide(b,2,BigDecimal.ROUND_UP)+\" up:小数点后第二位数+1\"); System.out.println(a.divide(b,2,BigDecimal.ROUND_HALF_DOWN)+\" \"+a2.divide(b,2,BigDecimal.ROUND_HALF_DOWN)+\" halfDown:小数点后第三大于5就把第二位数+1\"); System.out.println(a.divide(b,2,BigDecimal.ROUND_HALF_UP)+\" \"+a2.divide(b,2,BigDecimal.ROUND_HALF_UP)+\" halfUp:小数点后第三大于5就把第二位数+1\"); System.out.println(a.divide(b,2,BigDecimal.ROUND_HALF_EVEN)+\" \"+a2.divide(b,2,BigDecimal.ROUND_HALF_EVEN)+\" halfEven:小数点后第三大于5就把第二位数+1\"); &#125;&#125; 输出结果","comments":true,"tags":[{"name":"java","slug":"java","permalink":"http://www.caoyongjun.com/tags/java/"},{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"}]},{"title":"设计模式:原型模式","date":"2017-12-01T10:32:00.000Z","path":"2017/12/01/java-design-prototype/","text":"作为一个创建型模式,它的做用是复制一个已经实例化好的类，object类的clone方法是一个native本地方法，可直接操作内存中的二进制流，特别是复制大对象时，性能差别非常明显。clone时不会触发构造函数。 优点创建复杂或耗时的实例时比构造创建速度快 缺点实现Cloneable接口或Serializable接口 使用场景1、资源优化场景。2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。3、性能和安全要求的场景。4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。5、一个对象多个修改者的场景。6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone的方法创建一个对象，然后由工厂方法提供给调用者。 实现Cloneable接口会有两种拷贝方式它们的区别为下面图 现实生活中的例子 如何实现浅拷贝实现Clone接口，覆盖Clone方法 Prototype.java12345678910111213141516public class Prototype implements Cloneable &#123; private int id; private String name; private Book book; public Prototype clone()&#123; Prototype p=null; try &#123; p = (Prototype) super.clone(); return p; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125; //...省略setter和getter方法&#125; Test.java12345678910111213public static void main(String[] args) &#123; Book b=new Book(); b.setBookName(\"数学\"); Prototype pro = new Prototype(); pro.setBook(b); Prototype pro1 = pro.clone();//复制一个 b.setBookName(\"语文\");//更改bookname System.out.println(pro.getBook()==pro1.getBook()); System.out.println(\"original object:\" + pro.getBook().getBookName()); System.out.println(\"cloned object:\" + pro1.getBook().getBookName()); &#125; 输出结果123trueoriginal object:语文cloned object:语文 如何实现深拷贝由于浅拷贝默认只是把包含的对象引用复制了一份，所以也要把包含的对象也实现cloneable接口然后在原型clone方法里调用包含的对象clone方法 Prototype.java1234567891011121314151617public class Prototype implements Cloneable &#123; private int id; private String name; private Book book; public Prototype clone()&#123; Prototype p=null; try &#123; p = (Prototype) super.clone(); p.book = this.book.clone(); return p; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125; //...省略setter和getter方法&#125; Book.java12345678910111213public class Book implements Cloneable&#123; private String bookName; public Book clone()&#123; try &#123; return (Book) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125; //...省略setter和getter方法&#125; Test.java12345678910111213public static void main(String[] args) &#123; Book b=new Book(); b.setBookName(\"数学\"); Prototype pro = new Prototype(); pro.setBook(b); Prototype pro1 = pro.clone();//复制一个 b.setBookName(\"语文\");//更改bookname System.out.println(pro.getBook()==pro1.getBook()); System.out.println(\"original object:\" + pro.getBook().getBookName()); System.out.println(\"cloned object:\" + pro1.getBook().getBookName()); &#125; 输出结果123falseoriginal object:语文cloned object:数学 利用序列化串行方式复制实例原始类要实现serializable，包含的类也要实现serializable NewPrototype.java12345678910111213141516171819public class NewPrototype implements Serializable &#123; private int id; private Book book; public NewPrototype deepClone()&#123; try &#123; ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(this); ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); return (NewPrototype) oi.readObject(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); return null; &#125; &#125; //...省略setter和getter方法&#125; Book.java12public class Book implements Serializable//...省略其他 Test.java1234567891011public static void main(String[] args) &#123; Book book = new Book(); book.setBookName(\"语文\"); NewPrototype original = new NewPrototype(); original.setBook(book); //深度拷贝 NewPrototype deepClone = original.deepClone(); deepClone.getBook().setBookName(\"数学\"); System.out.println(\"original name:\" + original.getBook().getBookName()); System.out.println(\"cloned name:\" + deepClone.getBook().getBookName()); &#125; 输出12original name:语文cloned name:数学","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.caoyongjun.com/tags/设计模式/"}]},{"title":"性能测试:JMeter手把手配置","date":"2017-11-23T07:05:00.000Z","path":"2017/11/23/jmeter压测配置/","text":"为了测试接口的tps能力，使用了ApacheJMeter工具帮助我们模拟并发场景去压力测试 以下是JMeter的配置方法 1.新建线程组 1.1.设定线程数量等信息 2.添加用于并发的数据请求csv2.1.csv的数据文件 2.2.新建csv配置 2.3.配置cvs 3.添加http请求 3.1.设定http请求参数 4.察看树结果主要用于查看http请求信息对应的http返回结果 4.1.请求结果集 绿色代表成功，红色代表失败 响应数据 5.添加断言主要为了区分http请求失败与否用 5.1.写入判断依据 只要包含code等于200都算成功 6.添加聚合报告 6.1.聚合报告分析","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"JMeter","slug":"JMeter","permalink":"http://www.caoyongjun.com/tags/JMeter/"}]},{"title":"win10解决MySql Error Code 2006–MySQL服务器已离线错误","date":"2017-10-25T08:06:10.000Z","path":"2017/10/25/win10解决MySql Error Code 2006–MySQL服务器已离线错误/","text":"本地mysql在导入外部sql文件的时候爆出了MySql Error Code:2006–MySQL服务器已离线错误的错误信息查到解决方案是在my.ini文件的[mysqld]下面添加max_allowed_packet=500M 实在找不到实际执行的my.ini时请参考以下图就能找到了","comments":true,"tags":[{"name":"经验","slug":"经验","permalink":"http://www.caoyongjun.com/tags/经验/"}]},{"title":"Git:免密登录git项目","date":"2017-08-28T11:03:00.000Z","path":"2017/08/28/git-免密登录git项目/","text":"场景,码云中一台服务器上的git公钥,不能满足给多个git项目的公钥设置,会出现以下信息 所以找了一下git clone时直接提交密码和用户名格式是git clone https://$1:$2@$3 $1=用户名$2=密码$3=git路径 我的用户名是280856xxx@qq.com 但是得把@转为%40 280856xxx%40qq.com 不然会认为是git的路径密码是 mimaxx 带入参数的话就是以下git clone https://280856xxx%40qq.com:mimaxx@www.xxx.git","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"Git","slug":"Git","permalink":"http://www.caoyongjun.com/tags/Git/"}]},{"title":"理财-选择纯债基金","date":"2017-06-06T07:30:10.000Z","path":"2017/06/06/理财-选择纯债基金/","text":"资产配置多样化,就好比多个篮子分散放鸡蛋一样,纯债型基金虽然收益相对其他类型基金低,但确实最为稳健收益的产品,以下是听”力哥说理财”课后总结的一些选择纯债基金的方法让我们一步步操作选择最为稳健的基金吧！ 1. 登录天天基金网2. 点击进入基金排行后的画面如下 3. 在此页面中按以下的规则剔除掉部分基金 剔除投资可转债的基金 剔除小公司的基金 剔除规模较大的基金(20亿以上) 剔除同一基金公司旗下非王牌基金 4. 进一步要对剩下的基金们对以下的标准剔除后选择5个就成功了 综合费率最低的 申购费 赎回费 管理费 成立时间最长的 基金经理人年纪大的 管理时间长的 大家可以试一下,我是选择了5支基金,准备投资了。","comments":true,"tags":[{"name":"理财","slug":"理财","permalink":"http://www.caoyongjun.com/tags/理财/"},{"name":"基金","slug":"基金","permalink":"http://www.caoyongjun.com/tags/基金/"}]},{"title":"mybatis获取自增主键值","date":"2017-05-03T10:42:50.000Z","path":"2017/05/03/mybatis获取自增主键值/","text":"1.xml文件，返回的主键必须是自增的主键123&lt;insert id=\"insertResourceLock\" parameterType=\"lockOutDTO\" keyProperty=\"lockNo\" useGeneratedKeys=\"true\"&gt; insert into table_name (a,b,c...) values(#&#123;a&#125;,#&#123;b&#125;,#&#123;c&#125;...);&lt;/insert&gt; 2.dao方法和调用方法123void insertResourceLock(LockOutDTO lockOutDTO) throws Exception;lockOutDao.insertResourceLock(lockOutDTO); 3.调用后获取主键，主键是被映射到传入insert中的类中1lockOutDTO.getLockNo()","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"mybatis","slug":"mybatis","permalink":"http://www.caoyongjun.com/tags/mybatis/"}]},{"title":"mysql数据库之间同步字段","date":"2017-04-30T08:54:18.000Z","path":"2017/04/30/mysql数据库之间同步字段/","text":"项目末尾因为需求的几次改动dev和beta的数据库中的字段出现了几次不一样的情况,所以要找出不一样的部分并去同步他们的字段。 对于这种情况首先我觉得其他人也遇到过，但是起先不知要用什么关键词去寻找答案，后来找到了SQLyog工具同步的方法 以下操作图就是同步的方法","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"经验","slug":"经验","permalink":"http://www.caoyongjun.com/tags/经验/"}]},{"title":"生活:不该遇到的浪费注意力事件","date":"2017-04-26T03:25:28.000Z","path":"2017/04/26/life/","text":"生活中的遇到的坑早晨在某平台用半小时发了个帖子,本是想会有人赞同我的观点,可是没想还是有一些喷子,大早晨开始就和喷子们撕逼理论把好心情都给弄坏了。读了这么久的笑来老师的文章,居然还是不小心掉进了吞噬时间和注意力的三大坑里导致的后果是本来能在车上睡回笼觉保存体力的 莫名其妙的凑热闹 火急火燎的随大流 操碎了别人的心肝 1.莫名其妙的凑热闹发完帖子,还时不时去看喷子们的留言,真是凑热闹浪费时间 2.操碎了别人的心肝跟我的利益没有太大关联的别人家的事情,我却急的要死。 幸好元认知能力打断了这一切,告诉我的大脑系统不要踩坑远离那个APP,不要在下班之前再次打开帖子。要把所有的注意力放在成长上!!!","comments":true,"tags":[{"name":"生活","slug":"生活","permalink":"http://www.caoyongjun.com/tags/生活/"}]},{"title":"砖头人项目:7.消息通知功能实现","date":"2017-04-20T07:27:28.000Z","path":"2017/04/20/brickman-message/","text":"1.产品需求 从需求中提取了以下几点要完成 1.添加订阅动作用户 发布，评论，送花，拍砖 会插入到 订阅表(为了订阅到后期有人评论时收到提醒)2.评论内容动作时用户每次对事件评论后产生信息并插入到消息表(为了订阅者获取某个事件的最后一个消息)3.产生消息提醒每次用户登陆或者其他操作时会触发产生消息队列，每次订阅表中获取订阅的事件最后产生的评论信息，放入消息表里4.更新消息已读每次点击进入详情时更新全部的消息提醒 2.设计实现1.uml功能时序图以下图是产生订阅事件信息及提醒信息时序图 以下图是用户触发从提醒表提取未读消息，放入未读表中，以及更改已读消息状态的时序图 3.数据库设计 主要字段解释 （ 红色部分为以后拓展功能时用到的这次不会用到的字段 ） subscription=订阅表:{content_id:“事件Id”,user_id:”用户id”}notify=消息表:{sender_id:”对事件评论的用户id”,content_id:”事件Id“}user_notify=用户未读消息队列:{content_id:“事件Id”,user_id:”用户id”,read_yn:”读取状态”} 3.重要代码实现部分1.利用aop的after 每次拍砖，献花，评论后执行 后续的订阅，和生成评论消息动作， 此次使用aop 其实就是为了怕用户在做完主要动作后还要等待后续的动作会影响用户体验 1234567891011121314&lt;!-- 通知 --&gt;&lt;bean id =\"xmlHandler\" class=\"com.brickman.aop.XMLAdvice\"/&gt; &lt;!-- aop 配置 消息--&gt;&lt;aop:config&gt; &lt;aop:aspect id=\"aspectService\" ref=\"xmlHandler\"&gt; &lt;!-- aop 监听拍砖，献花，评论后 执行 后续插入订阅表和生成评论--&gt; &lt;aop:pointcut id=\"remindPoint\" expression=\"execution(* com.brickman.bo.*.insertRecord(..)) || execution(* com.brickman.bo.*.addComment(..))\"/&gt; &lt;aop:after method=\"doAfterInsertRemind\" pointcut-ref=\"remindPoint\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 2.每次如果订阅表里已经有了之前事件Id那么就更新订阅表的订阅时间 3.用户在登陆或者其他操作时触发生产未读消息队列 重点是找到notify中生成消息时间大于订阅表中的更新时间，并获取最大的notifyId相关数据 1234567SELECT MAX(b.notify_id) AS notify_id,b.content_id AS content_idFROM brick_subscription a,brick_notify bWHERE a.content_id=b.content_id AND a.user_id = #&#123;userId&#125; AND b.sender_id &lt;![CDATA[&lt;&gt;]]&gt; #&#123;userId&#125; AND a.update_time &lt;![CDATA[&lt;]]&gt; b.created_timeGROUP BY b.content_id 4.插入用户提醒队列表时 主要还要判断是否已经有过该事件如果有就不插入，为了避免两次mysql连接直接一次性写在一个sql中 12345678INSERT INTO brick_user_notify ( user_id, content_id, notify_id ) SELECT #&#123;userId&#125;,#&#123;contentId&#125;,#&#123;notifyId&#125; FROM DUAL WHERE NOT EXISTS ( SELECT 1 FROM brick_user_notify WHERE content_id=#&#123;contentId&#125; AND user_id=#&#123;userId&#125; AND notify_id=#&#123;notifyId&#125; ) 点击进入用户未读消息的事件后，会更新某个事件的所有未读消息为已读 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"}]},{"title":"工作经验:针对大批量不同数据生成相同的sql","date":"2017-04-18T16:04:28.000Z","path":"2017/04/19/work-experience/","text":"2013年刚工作不到一年时遇到了一个需求是对大量的数据(几万条词典数据)生成insert语句后给到DBA手里操作。由于工作经验不足的原因,当时自己想了个蠢办法是用方法一:java编写一个读取文件里的内容for循环读取数据然后生成insert的语句…(现在想想只能是一个打30分的低效办法)。后来又遇到了此种需求,如果还要用方法一的话我得改之前的java程序(因为我的当时能力没有写出公用的东西没能供应大多的表和其他如update,delete语句),后来问了下当年带我的师傅龙哥教我用他的方法二excel的方式大致像下面图 方法二图中红色为我要读取并生成的不同的数据,黑色是我固定的要生成的insert语句,”…”是省略。在excel中把这些语句复制粘贴到文本中由于每个excel格中间会有\\t的就是如下的图,可以在文本中替换一下。(现在想想只能是一个打60分勉强及格因为数据量大时会很卡)。 后来又遇到这种需求,庆幸当时的同事老赵教了我一招正则表达式替换,后来举一反三用到了后续的工作,以下是方法三 1(.+)\\t(.+)\\t(.+)\\t(.+)\\t(.+)\\t(.+) 注:每一个”(.+)”对应$i”i这里是1开始的不是0开始,如果是$0的话就是匹配整个内容”按照\\t去匹配的数据如果看不懂正则语法推荐这个博文入门30分钟正则表达式 (推荐使用EmEditor编辑器几万条数据都不会很卡这个方法我打99分,因为我相信还有其他方法更好地满足需求,这个截图是在线的正则工具http://tool.chinaz.com/regex/)","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"经验","slug":"经验","permalink":"http://www.caoyongjun.com/tags/经验/"}]},{"title":"Windows:cmd杀某个端口进程","date":"2017-04-18T11:54:28.000Z","path":"2017/04/18/windows-cmd/","text":"开发的时候启动tomcat会报端口占用的情况最快的解决方法是打开cmd然后输入一下命令查找到所占用的端口号 12netstat -aon | findstr 6080#就像linux中的ps -ef|grep 6080精确查找到 最后一条为pid 12taskkill /f /pid 41920#就像linux中的kill -9 41920","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"Windows","slug":"Windows","permalink":"http://www.caoyongjun.com/tags/Windows/"}]},{"title":"砖头人项目:6.MAVEN&GIT项目发布管理","date":"2017-04-17T06:53:28.000Z","path":"2017/04/17/brickman-maven_git/","text":"1.maven安装 123#wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo#yum -y install apache-maven 2.项目采用的是整体代码下载到服务器然后maven编译成class文件，tomcat加载class文件。由于是app接口，但是里面也包含了许多的长期固定不变的jar和一些静态H5页面js|html|css|jpg等信息，要把常修改的和静态不常更新的东西分离 为了动静分离 build_brickman.sh 内容 123456789101112131415161718192021222324#!/bin/shcur_date=$(date +%Y%m%d%H%M%S)folder_name=\"xxx_\"$cur_dateproject_path=/root/projectGitenv=\"dev\"cd $project_pathgit clone git@git.oschina.net:xxxx/xxxx.git $folder_namecd $folder_namemvn -P $env clean compile war:inplacecd $project_pathrm -rf brickmanln -s $folder_name brickmanln -s /data/img/real/html/brickman.html $folder_name/web/brickman.html ln -s /data/img/real/html/brickmanshare.html $folder_name/web/brickmanshare.html build_static_brickman.sh 内容 1234567891011121314151617#!/bin/shcur_date=$(date +%Y%m%d%H%M%S)folder_name=\"html_\"$cur_datestatic_path=/root/staticFilesGitcd $static_pathgit clone git@git.oschina.net:xxx/xxx.git $folder_namemv $folder_name/web/* $folder_name/rm -rf $folder_name/webrm -rf htmlln -s $static_path/$folder_name $static_path/html 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"}]},{"title":"砖头人项目:5.app中banner图片信息获取显示方法","date":"2017-04-16T09:53:28.000Z","path":"2017/04/16/brickman-appbanner/","text":"tomcat启动时一次性获取所有数据库中banner信息初始化到map中，因为常年不变所以每次前端请求时直接从静态map中直接返回对应的banner信息，当真的有banner信息修改时，通过admin方式调用更新map中的相应banner信息即可。主要还是避免每次都去连接宝贵的数据库资源。 1.application-service.xml 加载到这个文件时会触发init-method=”init“方法 12345&lt;bean id=\"commonDAO\" class=\"com.brickman.dao.impl.CommonDAOImpl\"/&gt;&lt;bean id =\"contextUtil\" class=\"com.brickman.utils.ContextUtil\" init-method=\"init\"&gt; &lt;property name=\"commonDAO\" ref=\"commonDAO\"/&gt; &lt;property name=\"advertisementDAO\" ref=\"advertisementDAO\"/&gt;&lt;/bean&gt; 2.初始化 连接数据库信息并存储到一个map中 1234567891011121314151617181920212223242526272829303132333435363738#所有的banner信息放入这个mapprivate static Map&lt;String, List&lt;BrickAdvertisement&gt;&gt; brickAdvertisementMapList = new HashMap&lt;String, List&lt;BrickAdvertisement&gt;&gt;();...省略#init的方法内容List&lt;BrickAdvertisement&gt; brickAdvertisementList01 = new ArrayList&lt;BrickAdvertisement&gt;();//启动页广告List&lt;BrickAdvertisement&gt; brickAdvertisementList02 = new ArrayList&lt;BrickAdvertisement&gt;();//首页广告List&lt;BrickAdvertisement&gt; brickAdvertisementList03 = new ArrayList&lt;BrickAdvertisement&gt;();//中间相机页广告List&lt;BrickAdvertisement&gt; brickAdvertisementList04 = new ArrayList&lt;BrickAdvertisement&gt;();//中间公益页广告 List&lt;BrickAdvertisement&gt; list = advertisementDAO.listAdvertisementByType(null); if (list != null &amp;&amp; list.size() &gt; 0) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; BrickAdvertisement advertisement = list.get(i); //设置他们对应的为止 switch (advertisement.getAdvertisementType()) &#123; case 1: brickAdvertisementList01.add(advertisement); break; case 2: brickAdvertisementList02.add(advertisement); break; case 3: brickAdvertisementList03.add(advertisement); break; case 4: brickAdvertisementList04.add(advertisement); break; default: break; &#125; &#125;&#125;brickAdvertisementMapList.put(\"1\", brickAdvertisementList01);brickAdvertisementMapList.put(\"2\", brickAdvertisementList02);brickAdvertisementMapList.put(\"3\", brickAdvertisementList03);brickAdvertisementMapList.put(\"4\", brickAdvertisementList04); 3.前端获取某个banner类型图片 1List&lt;BrickAdvertisement&gt; list=ContextUtil.getBrickAdvertisementMapList().get(advertisementType); 4.后台admin修改了banner信息，触发更新信息 1234List&lt;BrickAdvertisement&gt; list = advertisementBO.listAdvertisementByType(paramMap);if(list !=null &amp;&amp; list.size()&gt;0)&#123; ContextUtil.getInstance().getBrickAdvertisementMapList().put(advertisementType, list);//重新设置&#125; 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"}]},{"title":"砖头人项目:4.qq登陆授权","date":"2017-04-14T08:49:28.000Z","path":"2017/04/14/brickman-qq_login/","text":"1.引入第三方提供的jar包pom.xml，systemPath为存放路径 1234567&lt;dependency&gt; &lt;groupId&gt;org.other&lt;/groupId&gt; &lt;artifactId&gt;qq&lt;/artifactId&gt; &lt;version&gt;20160812&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;basedir&#125;/web/WEB-INF/lib/Sdk4J.jar&lt;/systemPath&gt;&lt;/dependency&gt; 2.配置qqconnectconfig.properties，前两个参数是申请授权登陆时qq下发的，scope是我们需要用到的作用域获取用户信息 1234567app_ID = **********app_KEY = **********scope = get_user_infobaseURL = https://graph.qq.com/getUserInfoURL = https://graph.qq.com/user/get_user_infoaccessTokenURL = https://graph.qq.com/oauth2.0/token.....省略 3.后端程序获取前端授权qq后返回的数据 accessToken:“授权返回的令牌”，openId:”qq唯一的id” 1234//利用前端返回的信息获取用户的qq空间信息UserInfo qzoneUserInfo = new UserInfo(accessToken, openId);//获取用户详细信息UserInfoBean userInfoBean = qzoneUserInfo.getUserInfo(); 4.然后使用openId查看用户表有无此人，如果无就新生一条用户记录。 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"}]},{"title":"砖头人项目:3.Tomcat配置篇","date":"2017-04-13T08:54:28.000Z","path":"2017/04/13/brickman-tomcat/","text":"1.解压 1tar -zxvf apache-tomcat-7.0.22.tar.gz 2.在%TOMCAT_HOME/conf 下创建一个专门用于砖头人使用的配置文件server-brickman.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;Server port=\"xxxx\" shutdown=\"SHUTDOWN\"&gt; ....省略 &lt;Service name=\"Catalina\"&gt; &lt;Connector port=\"xxxx\" protocol=\"HTTP/1.1\" URIEncoding=\"UTF-8\" #对所有get方式请求进行统一的重新编码解码 useBodyEncodingForURI=\"true\" #根据响应该请求的页面的request.setCharacterEncoding参数对数据进行的重新编码，不同的页面可以有不同的重新编码的编码 connectionTimeout=\"20000\" #当访客网络连接后，服务器等待第一行Request头出现的时间。单位是毫秒 redirectPort=\"xxxx\" #当用户访问非https的资源而该资源又需要https方式访问时，tomcat会自动重定向到https端口，一般https使用 TCP 443端口 maxHttpHeaderSize=\"8192\" #注设置最大的head大小 /&gt; &lt;Connector port=\"xxxx\" protocol=\"AJP/1.3\" redirectPort=\"xxxx\" URIEncoding=\"UTF-8\" useBodyEncodingForURI=\"true\"/&gt; &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; ....省略 &lt;Host name=\"localhost\" #对应虚拟主机,也可以直接填写服务器的 ip unpackWARs=\"false\" #设置是否自动展开 war 压缩包再运行 Web 应用程序，默认值是 true。 autoDeploy=\"false\" #是否允许自动部署,默认值是 true,即表示 Tomcat 会自动检测 appBase 目录下面的文件变化从而自动应用到正在运行的 Web 应用程序。 &gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"/xxx.../logs\" prefix=\"brickman_access_log.\" suffix=\".txt\" pattern=\"combined\" /&gt; &lt;Context docBase=\"/xxx.../brickman/web\" #指定绝对路径一直到web目录下 path=\"\" reloadable=\"false\" #如果是true那么每当相关文件改变时，Tomcat会停止web app并释放内存 allowLinking=\"true\" #因为官网的页面是另一个由nginx管理的静态页面项目，所以使用了软连接指定 /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 3.配置cronolog来管理tomcat产生的日志切割 123456789101112131415161718191、下载（最新版本） #wget http://cronolog.org/download/cronolog-1.6.2.tar.gz 2、解压缩 #tar zxvf cronolog-1.6.2.tar.gz 3、进入cronolog安装文件所在目录 #cd cronolog-1.6.2 4、运行安装 #./configure #make #make install 5、查看cronolog安装后所在目录（验证安装是否成功） #which cronolog 一般情况下显示为：/usr/local/sbin/cronolog 6、要想分割tomcat的catalina.out，需作如下工作：修改%TOMCAT_HOME%/bin目录下的catalina.sh文件中的org.apache.catalina.startup.Bootstrap “$@” start \\&gt;&gt; “$CATALINA_BASE”/logs/catalina.out 2&gt;&amp;1 &amp;替换为org.apache.catalina.startup.Bootstrap \"$@\" start \\ |/usr/local/sbin/cronolog \"$CATALINA_BASE\"/logs/catalina.%Y-%m-%d.out &gt;&gt; /dev/null 2&gt;&amp;1 &amp; 4.启动操作 1%TOMCAT_HOME%/bin/startup.sh -config %TOMCAT_HOME%/conf/server-brickman.xml 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"}]},{"title":"技术:js正则表达式","date":"2017-04-12T10:32:04.000Z","path":"2017/04/12/js-正则表达式/","text":"123var date=\"2017-04-01\";var reg=/\\-/g; //正则表达式，-为需要被换的内容,g为全局的date.replace(reg,\"\"); 结果输出内容为 “20170401”","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"js","slug":"js","permalink":"http://www.caoyongjun.com/tags/js/"}]},{"title":"砖头人项目:2.Nginx配置篇","date":"2017-04-12T07:50:28.000Z","path":"2017/04/12/brickman-nginx/","text":"砖头人:nginx主要用于项目中的静态资源访问请求，以及拦截爬虫类的攻击请求. 本来想用apache httpd考虑到nginx比较方便配置，就使用nginx了。 1.nginx.conf 配置程序端 由于前期时间域名一直没有通过审核所以，前期使用的是ip访问，后期有了域名后为了支持旧版本以下配置就可支持ip和域名的访问 这里为了保护服务器省略其他配置 只留需要被展示的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445upstream www.brickman.cn&#123; //代理的域名 server localhost:xx; //转跳指定的tomcat端口项目&#125;server &#123; listen 80; server_name localhost; ... ... location / &#123; proxy_pass http://www.brickman.cn; #反向代理域名 ... ... &#125; include agent_deny.conf;#为了防止像性能测试/shell脚本/爬虫类的访问拦截配置 ... ...&#125;server &#123; listen 80; server_name img.brickman.cn;#使用域名后的访问 location ~* ^.+\\.(jpg|js|html|png|css|apk|ttf|woff|ico)$ &#123;#当访问这些后缀时会访问到特定路径下的静态资源 root xxx;#静态路径 add_header Access-Control-Allow-Origin *;#主要是ttf/woff资源在不同域下会丢失 所以加入这个 access_log on; expires 30d;#缓存到用户的机器中30天 &#125; ... ...&#125;server &#123; listen xxxx;#监听静态端口 server_name 127.0.0.1:xxxx;#之前使用ip的时候的访问 location ~* ^.+\\.(jpg|js|html|png|css|apk|ttf|woff|ico)$ &#123; root /data/img/real; add_header Access-Control-Allow-Origin *; access_log on; expires 30d; &#125;&#125; 2.agent_deny.conf 拦截使用的配置 123456789101112131415161718if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123; return 403; &#125; if ($http_user_agent ~ \"FeedDemon|JikeSpider|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|CoolpadWebkit|Java|Feedly|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|YisouSpider|HttpClient|MJ12bot|heritrix|EasouSpider|LinkpadBot|Ezooms|^$\" ) &#123; return 403; &#125; if ($request_method !~ ^(GET|HEAD|POST)$) &#123; return 403; &#125; if ($http_user_agent ~ \"Mozilla/4.0\\ compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727\") &#123; return 404; &#125; if ( $http_user_agent ~ \"ApacheBench|webBench|Java/|http_load|must-revalidate|wget\" )&#123; return 403;&#125; 主要缓存以下资源 官网=http://www.brickman.cn 关于我们=http://img.brickman.cn/html/brickman.html 反馈我们=http://img.brickman.cn/html/brickmanback.html 用户头像和事件的压缩图和原图 最重要的是 vi /etc/hosts 中添加需要的域名 1127.0.0.1 www.brickman.cn brickman.cn img.brickman.cn 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"}]},{"title":"砖头人项目:1.架构设计实现篇","date":"2017-04-11T10:53:28.000Z","path":"2017/04/11/brickman-architecture/","text":"1.服务器使用的是linuxCentOS7 2.git使用码云来托管代码 3.接口文档编写使用showdoc.cc 4.任务分配使用teambition软件 如果此时此刻，你也在北漂、上漂、广漂、深漂，那这里就是你的新家：www.brickman.cn。欢迎加入砖头人大家庭，现邀请你体验为你定制开发的“砖头人app”。","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"},{"name":"项目总结","slug":"项目总结","permalink":"http://www.caoyongjun.com/tags/项目总结/"}]},{"title":"软件测试神一样的超级好用的selenium 原创java util","date":"2017-04-10T11:37:47.000Z","path":"2017/04/10/selenium/","text":"以下是自己封装的seleniumJava工具类 可以自行拷贝用到项目中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198import java.awt.AWTException;import java.awt.Robot;import java.awt.event.KeyEvent;import java.io.File;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import org.openqa.selenium.JavascriptExecutor;import org.openqa.selenium.TakesScreenshot;import org.apache.commons.io.FileUtils;import org.openqa.selenium.By;import org.openqa.selenium.OutputType;import org.openqa.selenium.WebDriver;import org.openqa.selenium.WebElement;import org.openqa.selenium.chrome.ChromeDriver;import org.openqa.selenium.firefox.FirefoxDriver;import org.openqa.selenium.htmlunit.HtmlUnitDriver;import org.openqa.selenium.ie.InternetExplorerDriver;import org.openqa.selenium.interactions.Actions;import org.openqa.selenium.support.ui.ExpectedCondition;import org.openqa.selenium.support.ui.WebDriverWait;public class SeleniumUtil &#123; private static WebDriver webDriver; private static WebElement webElement; private static Robot robot; private static By byelement; /*javascript*/ public void Script ( String script , WebElement element ) &#123; JavascriptExecutor js=(JavascriptExecutor)webDriver; if ( element==null ) &#123; js.executeScript(script); &#125; else &#123; js.executeScript(script, element); &#125; &#125; /*javascript 返回数据*/ public String ScriptString ( String script ) &#123; JavascriptExecutor js=(JavascriptExecutor)webDriver; String s=(String) js.executeScript(script); return s; &#125; /** * 初始化 * @param select * 1:Firefox * 2:IE * 3:Chrome * 4:后台执行 * @param browserpath * 选择本地浏览路径 */ public void Init ( int switchbrowser , String browserpath ) &#123; switch ( switchbrowser ) &#123; case 1: System.setProperty ( \"webdriver.firefox.bin\" , browserpath ); webDriver = new FirefoxDriver(); webDriver.manage().window().maximize(); break; case 2: System.setProperty(\"webdriver.ie.driver\", browserpath); webDriver = new InternetExplorerDriver(); webDriver.manage().window().maximize(); break; case 3: System.setProperty(\"webdriver.chrome.driver\", browserpath); webDriver = new ChromeDriver(); webDriver.manage().window().maximize(); break; case 4: webDriver = new HtmlUnitDriver(); break; &#125; &#125; //复制 protected void CopyKeys() &#123; try &#123; robot = new Robot(); robot.keyPress(KeyEvent.VK_CONTROL); robot.keyPress(KeyEvent.VK_C); robot.keyRelease(KeyEvent.VK_CONTROL); robot.keyRelease(KeyEvent.VK_C); &#125; catch (AWTException e) &#123; e.printStackTrace(); &#125; &#125; //粘贴 protected void PasteKeys() &#123; try &#123; robot = new Robot(); robot.keyPress(KeyEvent.VK_CONTROL); robot.keyPress(KeyEvent.VK_V); robot.keyRelease(KeyEvent.VK_CONTROL); robot.keyRelease(KeyEvent.VK_V); &#125; catch (AWTException e) &#123; e.printStackTrace(); &#125; &#125; /** * 拖拽 * @param by 要多拽的元素 * @param target 目的地 */ protected void DragAndDrop ( By by , By target ) &#123; (new Actions(webDriver)).dragAndDrop(webDriver.findElement(by), webDriver.findElement(target)).perform(); &#125; //传入值 protected void SendKeys(By by, String value)&#123; webDriver.findElement(by).sendKeys(value); &#125; /** * 截图 * @param outpath 导出截图后的路径 文件名是以当前时间 */ public void GetScreen ( String outpath ) &#123; File screenShotFile = ((TakesScreenshot)webDriver).getScreenshotAs(OutputType.FILE); try &#123; FileUtils.copyFile(screenShotFile, new File ( outpath + \"/\" + getSysTime() + \".jpg\" ) ); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /**获取元素 * @param by * @param second 查找需要时间 */ public void Wait( final By by , int second ) &#123; WebDriverWait wait = new WebDriverWait(webDriver,second); wait.until(new ExpectedCondition&lt;WebElement&gt;()&#123; public WebElement apply(WebDriver d) &#123; return d.findElement(by); &#125; &#125;); &#125; //打开浏览器 public void Start ( String url ) &#123; webDriver.get( url ); &#125; //结束 public void Stop () &#123; webDriver.quit(); &#125; //获取当前时间 public static String getSysTime()&#123; SimpleDateFormat filename = new SimpleDateFormat(\"yyyyMMdd_HHmmss\"); return filename.format(new Date()); &#125; // 睡眠 public void Sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static WebDriver getWebDriver() &#123; return webDriver; &#125; public static void setWebDriver(WebDriver webDriver) &#123; SeleniumUtil.webDriver = webDriver; &#125; public static WebElement getWebElement() &#123; return webElement; &#125; public static void setWebElement(WebElement webElement) &#123; SeleniumUtil.webElement = webElement; &#125; public static By getByelement() &#123; return byelement; &#125; public static void setByelement(By byelement) &#123; SeleniumUtil.byelement = byelement; &#125;&#125;","comments":true,"tags":[{"name":"java","slug":"java","permalink":"http://www.caoyongjun.com/tags/java/"},{"name":"技术","slug":"技术","permalink":"http://www.caoyongjun.com/tags/技术/"}]}]